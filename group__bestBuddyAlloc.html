<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>R_RTOS: Modified Best Buddy Memory Allocator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">R_RTOS
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">DistributedRealTimeOperatingSystemfortheARMCortexMArchitecture</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__bestBuddyAlloc.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Modified Best Buddy Memory Allocator<div class="ingroups"><a class="el" href="group__mem.html">Memory Management</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Modified Best Buddy Memory Allocator.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmemMngrHead.html">memMngrHead</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the full information about the memory block.  <a href="structmemMngrHead.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmemBlckhead.html">memBlckhead</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the only the flag information about the memory block.  <a href="structmemBlckhead.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gacf143577800376dd931c059ecc61ba06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacf143577800376dd931c059ecc61ba06"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#gacf143577800376dd931c059ecc61ba06">malloc</a>&#160;&#160;&#160;<a class="el" href="group__bestBuddyAlloc.html#gaa413533dce906197feee17e35a9d78e4">rMalloc</a></td></tr>
<tr class="memdesc:gacf143577800376dd931c059ecc61ba06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redefine malloc to rMalloc in order not to have to alter the already existing code. <br /></td></tr>
<tr class="separator:gacf143577800376dd931c059ecc61ba06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84beef8cc122add35118ec7cd35286c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga84beef8cc122add35118ec7cd35286c4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#ga84beef8cc122add35118ec7cd35286c4">calloc</a>&#160;&#160;&#160;<a class="el" href="group__bestBuddyAlloc.html#gad0512fc8c659f4685efe22e93cb3b9fe">rCalloc</a></td></tr>
<tr class="memdesc:ga84beef8cc122add35118ec7cd35286c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redefine calloc to rCalloc in order not to have to alter the already existing code. <br /></td></tr>
<tr class="separator:ga84beef8cc122add35118ec7cd35286c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b739878adcdb46fb5d209af7ce79628"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1b739878adcdb46fb5d209af7ce79628"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#ga1b739878adcdb46fb5d209af7ce79628">realloc</a>&#160;&#160;&#160;<a class="el" href="group__bestBuddyAlloc.html#ga6c4582e0c129b415d6d5bf7753f8a30c">rRealloc</a></td></tr>
<tr class="memdesc:ga1b739878adcdb46fb5d209af7ce79628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redefine realloc to rRealloc in order not to have to alter the already existing code. <br /></td></tr>
<tr class="separator:ga1b739878adcdb46fb5d209af7ce79628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c6efa7679f8cd9f61af96e105017560"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2c6efa7679f8cd9f61af96e105017560"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#ga2c6efa7679f8cd9f61af96e105017560">free</a>&#160;&#160;&#160;<a class="el" href="group__bestBuddyAlloc.html#gae3783e27f134ba0fcd5d95ff9506e722">rFree</a></td></tr>
<tr class="memdesc:ga2c6efa7679f8cd9f61af96e105017560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redefine free to rFree in order not to have to alter the already existing code. <br /></td></tr>
<tr class="separator:ga2c6efa7679f8cd9f61af96e105017560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6fbf92ebf7fa6ce06aec092d6b02393"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#gac6fbf92ebf7fa6ce06aec092d6b02393">BIGGEST_BLCK</a>&#160;&#160;&#160;((<a class="el" href="group__bestBuddyAlloc.html#ga344bd71f9b6293a6f87a7c58de364fe8">BlckSize</a>)0x100u)</td></tr>
<tr class="memdesc:gac6fbf92ebf7fa6ce06aec092d6b02393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the biggest possible buddy.  <a href="#gac6fbf92ebf7fa6ce06aec092d6b02393">More...</a><br /></td></tr>
<tr class="separator:gac6fbf92ebf7fa6ce06aec092d6b02393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9df40dd9c205133d63a595febb7149a4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#ga9df40dd9c205133d63a595febb7149a4">BIGGEST_BLCK_MSK</a>&#160;&#160;&#160;((<a class="el" href="group__bestBuddyAlloc.html#ga344bd71f9b6293a6f87a7c58de364fe8">BlckSize</a>)(<a class="el" href="group__bestBuddyAlloc.html#gac6fbf92ebf7fa6ce06aec092d6b02393">BIGGEST_BLCK</a> - (<a class="el" href="group__bestBuddyAlloc.html#ga344bd71f9b6293a6f87a7c58de364fe8">BlckSize</a>)1u))</td></tr>
<tr class="memdesc:ga9df40dd9c205133d63a595febb7149a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask for blocks bigger than BIGGER_BLCK.  <a href="#ga9df40dd9c205133d63a595febb7149a4">More...</a><br /></td></tr>
<tr class="separator:ga9df40dd9c205133d63a595febb7149a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga359dc7027f36b533d6a4e00cb9be1287"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#ga359dc7027f36b533d6a4e00cb9be1287">SMALLEST_BLCK</a>&#160;&#160;&#160;((<a class="el" href="group__bestBuddyAlloc.html#ga344bd71f9b6293a6f87a7c58de364fe8">BlckSize</a>)0x8u)</td></tr>
<tr class="memdesc:ga359dc7027f36b533d6a4e00cb9be1287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the smallest possible buddy.  <a href="#ga359dc7027f36b533d6a4e00cb9be1287">More...</a><br /></td></tr>
<tr class="separator:ga359dc7027f36b533d6a4e00cb9be1287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fa793b67a572377552189c6a7765185"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#ga9fa793b67a572377552189c6a7765185">SMALLER_BLCK_MSK</a>&#160;&#160;&#160;((<a class="el" href="group__bestBuddyAlloc.html#ga344bd71f9b6293a6f87a7c58de364fe8">BlckSize</a>)(<a class="el" href="group__bestBuddyAlloc.html#ga359dc7027f36b533d6a4e00cb9be1287">SMALLEST_BLCK</a> - (<a class="el" href="group__bestBuddyAlloc.html#ga344bd71f9b6293a6f87a7c58de364fe8">BlckSize</a>)1u))</td></tr>
<tr class="memdesc:ga9fa793b67a572377552189c6a7765185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask for blocks smaller than SMALLEST_BLCK.  <a href="#ga9fa793b67a572377552189c6a7765185">More...</a><br /></td></tr>
<tr class="separator:ga9fa793b67a572377552189c6a7765185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf59e67b443ce5f091d7c9b6be66db1c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#gadf59e67b443ce5f091d7c9b6be66db1c">SMALLER_BLCK_DIVISOR</a>&#160;&#160;&#160;(<a class="el" href="group__bestBuddyAlloc.html#gab59fbcd8b7379f49357e6f3ee03fd623">MemIndex</a>)(0x3u)</td></tr>
<tr class="memdesc:gadf59e67b443ce5f091d7c9b6be66db1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit shifts needed for a division through SMALLEST_BLCK.  <a href="#gadf59e67b443ce5f091d7c9b6be66db1c">More...</a><br /></td></tr>
<tr class="separator:gadf59e67b443ce5f091d7c9b6be66db1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a6befd630ea1c2ab260266f7466540c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#ga8a6befd630ea1c2ab260266f7466540c">CACHE_SIZE</a>&#160;&#160;&#160;((uint8_t)0x10u)</td></tr>
<tr class="memdesc:ga8a6befd630ea1c2ab260266f7466540c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the object cache.  <a href="#ga8a6befd630ea1c2ab260266f7466540c">More...</a><br /></td></tr>
<tr class="separator:ga8a6befd630ea1c2ab260266f7466540c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga344bd71f9b6293a6f87a7c58de364fe8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga344bd71f9b6293a6f87a7c58de364fe8"></a>
typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#ga344bd71f9b6293a6f87a7c58de364fe8">BlckSize</a></td></tr>
<tr class="memdesc:ga344bd71f9b6293a6f87a7c58de364fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of a block of memory. <br /></td></tr>
<tr class="separator:ga344bd71f9b6293a6f87a7c58de364fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45bb5f14f010053b22d49b81e127e49c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga45bb5f14f010053b22d49b81e127e49c"></a>
typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#ga45bb5f14f010053b22d49b81e127e49c">MemPoolID</a></td></tr>
<tr class="memdesc:ga45bb5f14f010053b22d49b81e127e49c"><td class="mdescLeft">&#160;</td><td class="mdescRight">8Bit ID value of a memory pool. <br /></td></tr>
<tr class="separator:ga45bb5f14f010053b22d49b81e127e49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4a88481e0625b4d3f7dcaf368e5a40b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf4a88481e0625b4d3f7dcaf368e5a40b"></a>
typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#gaf4a88481e0625b4d3f7dcaf368e5a40b">MemFlags</a></td></tr>
<tr class="memdesc:gaf4a88481e0625b4d3f7dcaf368e5a40b"><td class="mdescLeft">&#160;</td><td class="mdescRight">16Bit flag value. <br /></td></tr>
<tr class="separator:gaf4a88481e0625b4d3f7dcaf368e5a40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ec0ea53f55f2ecffcafffdc7a0df532"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#ga6ec0ea53f55f2ecffcafffdc7a0df532">stdPtr</a></td></tr>
<tr class="memdesc:ga6ec0ea53f55f2ecffcafffdc7a0df532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple void pointer.  <a href="#ga6ec0ea53f55f2ecffcafffdc7a0df532">More...</a><br /></td></tr>
<tr class="separator:ga6ec0ea53f55f2ecffcafffdc7a0df532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab59fbcd8b7379f49357e6f3ee03fd623"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab59fbcd8b7379f49357e6f3ee03fd623"></a>
typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#gab59fbcd8b7379f49357e6f3ee03fd623">MemIndex</a></td></tr>
<tr class="memdesc:gab59fbcd8b7379f49357e6f3ee03fd623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for indexing memory blocks. <br /></td></tr>
<tr class="separator:gab59fbcd8b7379f49357e6f3ee03fd623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga060a3e62e4e65a36938eb723871b107f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga060a3e62e4e65a36938eb723871b107f"></a>
typedef struct <a class="el" href="structmemMngrHead.html">memMngrHead</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a></td></tr>
<tr class="memdesc:ga060a3e62e4e65a36938eb723871b107f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmemMngrHead.html" title="Contains the full information about the memory block. ">memMngrHead</a> <br /></td></tr>
<tr class="separator:ga060a3e62e4e65a36938eb723871b107f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d1f0e9486b1c1ad87279460241c1d33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1d1f0e9486b1c1ad87279460241c1d33"></a>
typedef struct <a class="el" href="structmemBlckhead.html">memBlckhead</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#ga1d1f0e9486b1c1ad87279460241c1d33">MemBlckHead</a></td></tr>
<tr class="memdesc:ga1d1f0e9486b1c1ad87279460241c1d33"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmemBlckhead.html" title="Contains the only the flag information about the memory block. ">memBlckhead</a> <br /></td></tr>
<tr class="separator:ga1d1f0e9486b1c1ad87279460241c1d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga369bb7fea11c364989320098b5499651"><td class="memItemLeft" align="right" valign="top"><a class="el" href="R__RTOS__inc_8h.html#aa72989791cb0897faf8ff36202a4e07f">RetCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#ga369bb7fea11c364989320098b5499651">initMEM</a> (void)</td></tr>
<tr class="memdesc:ga369bb7fea11c364989320098b5499651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the memory manager.  <a href="#ga369bb7fea11c364989320098b5499651">More...</a><br /></td></tr>
<tr class="separator:ga369bb7fea11c364989320098b5499651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga359c3d7d5c206729eeb7ae10b382e5bd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#ga359c3d7d5c206729eeb7ae10b382e5bd">delMemBlck</a> (<a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const blckToDelete)</td></tr>
<tr class="memdesc:ga359c3d7d5c206729eeb7ae10b382e5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a block from the list it is contained in.  <a href="#ga359c3d7d5c206729eeb7ae10b382e5bd">More...</a><br /></td></tr>
<tr class="separator:ga359c3d7d5c206729eeb7ae10b382e5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae3a581fb679a9ed0df58140874d43ad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#gaae3a581fb679a9ed0df58140874d43ad">getAdjacentPrevBlck</a> (<a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const curBlck)</td></tr>
<tr class="memdesc:gaae3a581fb679a9ed0df58140874d43ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate and return the block prior to the given block.  <a href="#gaae3a581fb679a9ed0df58140874d43ad">More...</a><br /></td></tr>
<tr class="separator:gaae3a581fb679a9ed0df58140874d43ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8756c9ebce613b7cd9224a54b2e9100a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#ga8756c9ebce613b7cd9224a54b2e9100a">getAdjacentNxtBlck</a> (<a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const curBlck)</td></tr>
<tr class="memdesc:ga8756c9ebce613b7cd9224a54b2e9100a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate and return the block next to the given block.  <a href="#ga8756c9ebce613b7cd9224a54b2e9100a">More...</a><br /></td></tr>
<tr class="separator:ga8756c9ebce613b7cd9224a54b2e9100a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d6be2a4fa01e852b26426b480d69d02"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#ga3d6be2a4fa01e852b26426b480d69d02">getBuddyBlck</a> (<a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const curBlck)</td></tr>
<tr class="memdesc:ga3d6be2a4fa01e852b26426b480d69d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate and return the buddy block to the given block.  <a href="#ga3d6be2a4fa01e852b26426b480d69d02">More...</a><br /></td></tr>
<tr class="separator:ga3d6be2a4fa01e852b26426b480d69d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c8770718e6aa3266f716d039806d1cd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#ga7c8770718e6aa3266f716d039806d1cd">fitBlckBackIntoFreeLst</a> (<a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const curBlck)</td></tr>
<tr class="memdesc:ga7c8770718e6aa3266f716d039806d1cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the given block back into the free memory blocks list according to its address.  <a href="#ga7c8770718e6aa3266f716d039806d1cd">More...</a><br /></td></tr>
<tr class="separator:ga7c8770718e6aa3266f716d039806d1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68b69c7cf2857ba17ceaa63769baa560"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#ga68b69c7cf2857ba17ceaa63769baa560">mergeMemBlck</a> (<a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> **blckToMerge)</td></tr>
<tr class="memdesc:ga68b69c7cf2857ba17ceaa63769baa560"><td class="mdescLeft">&#160;</td><td class="mdescRight">The given memory block is merged with its buddy block if it is free and not cached.  <a href="#ga68b69c7cf2857ba17ceaa63769baa560">More...</a><br /></td></tr>
<tr class="separator:ga68b69c7cf2857ba17ceaa63769baa560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad70561f8e55c5019589d8ef867b539b5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#gad70561f8e55c5019589d8ef867b539b5">reMergeMemBlck</a> (<a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> **blckToMerge)</td></tr>
<tr class="memdesc:gad70561f8e55c5019589d8ef867b539b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The given memory block is merged continuously with its buddy blocks as long as these are neither taken nor cached.  <a href="#gad70561f8e55c5019589d8ef867b539b5">More...</a><br /></td></tr>
<tr class="separator:gad70561f8e55c5019589d8ef867b539b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7289114e196270ab93c5dda852b324a2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#ga7289114e196270ab93c5dda852b324a2">splitMemBlck</a> (<a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> **const blckToSplit)</td></tr>
<tr class="memdesc:ga7289114e196270ab93c5dda852b324a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The given memory block is split into two equally sized buddies.  <a href="#ga7289114e196270ab93c5dda852b324a2">More...</a><br /></td></tr>
<tr class="separator:ga7289114e196270ab93c5dda852b324a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a92216fae1dd09795d592eab2bc28c6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#ga2a92216fae1dd09795d592eab2bc28c6">unMergeUnevenBlcks</a> (<a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const blckToUnMerge)</td></tr>
<tr class="memdesc:ga2a92216fae1dd09795d592eab2bc28c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The given memory block is split into the unequal buddy blocks it consisted of.  <a href="#ga2a92216fae1dd09795d592eab2bc28c6">More...</a><br /></td></tr>
<tr class="separator:ga2a92216fae1dd09795d592eab2bc28c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7215e3278b6a85128484aa16a849b4a7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#ga7215e3278b6a85128484aa16a849b4a7">mergeUnevenBlocks</a> (<a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const basis, <a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const added)</td></tr>
<tr class="memdesc:ga7215e3278b6a85128484aa16a849b4a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The two given memory blocks of unequal size are merged into one memory block.  <a href="#ga7215e3278b6a85128484aa16a849b4a7">More...</a><br /></td></tr>
<tr class="separator:ga7215e3278b6a85128484aa16a849b4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61407be52d8b17c8e4a0a353a23aaa8b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#ga61407be52d8b17c8e4a0a353a23aaa8b">shrinkCacheFIFO</a> (void)</td></tr>
<tr class="memdesc:ga61407be52d8b17c8e4a0a353a23aaa8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the last element out of the cache.  <a href="#ga61407be52d8b17c8e4a0a353a23aaa8b">More...</a><br /></td></tr>
<tr class="separator:ga61407be52d8b17c8e4a0a353a23aaa8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2abedb3bd0e43ce448ea9b82ef8f5347"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#ga2abedb3bd0e43ce448ea9b82ef8f5347">addBlckToCache</a> (<a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const blckToAdd)</td></tr>
<tr class="memdesc:ga2abedb3bd0e43ce448ea9b82ef8f5347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the given block to the objCache.  <a href="#ga2abedb3bd0e43ce448ea9b82ef8f5347">More...</a><br /></td></tr>
<tr class="separator:ga2abedb3bd0e43ce448ea9b82ef8f5347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa413533dce906197feee17e35a9d78e4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#gaa413533dce906197feee17e35a9d78e4">rMalloc</a> (<a class="el" href="R__RTOS__inc_8h.html#ac9a1d73dc119532df42abb4a69b2aa1e">MemSize</a> desiredSize)</td></tr>
<tr class="memdesc:gaa413533dce906197feee17e35a9d78e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block of memory satisfying the desiredSize property.  <a href="#gaa413533dce906197feee17e35a9d78e4">More...</a><br /></td></tr>
<tr class="separator:gaa413533dce906197feee17e35a9d78e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0512fc8c659f4685efe22e93cb3b9fe"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#gad0512fc8c659f4685efe22e93cb3b9fe">rCalloc</a> (const <a class="el" href="R__RTOS__inc_8h.html#ac9a1d73dc119532df42abb4a69b2aa1e">MemSize</a> desiredSize)</td></tr>
<tr class="separator:gad0512fc8c659f4685efe22e93cb3b9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c4582e0c129b415d6d5bf7753f8a30c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#ga6c4582e0c129b415d6d5bf7753f8a30c">rRealloc</a> (void *ptrToExistingMem, <a class="el" href="R__RTOS__inc_8h.html#ac9a1d73dc119532df42abb4a69b2aa1e">MemSize</a> desiredSize)</td></tr>
<tr class="memdesc:ga6c4582e0c129b415d6d5bf7753f8a30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block of memory satisfying the desiredSize property.  <a href="#ga6c4582e0c129b415d6d5bf7753f8a30c">More...</a><br /></td></tr>
<tr class="separator:ga6c4582e0c129b415d6d5bf7753f8a30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3783e27f134ba0fcd5d95ff9506e722"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#gae3783e27f134ba0fcd5d95ff9506e722">rFree</a> (void *pToBeFreed)</td></tr>
<tr class="memdesc:gae3783e27f134ba0fcd5d95ff9506e722"><td class="mdescLeft">&#160;</td><td class="mdescRight">The provided block of memory will be added to the memory block cache.  <a href="#gae3783e27f134ba0fcd5d95ff9506e722">More...</a><br /></td></tr>
<tr class="separator:gae3783e27f134ba0fcd5d95ff9506e722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga811bc61478384c58a95488701c4e53f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#ga811bc61478384c58a95488701c4e53f2">rFullyFree</a> (<a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *blckToFullyFree)</td></tr>
<tr class="memdesc:ga811bc61478384c58a95488701c4e53f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a block of memory previously allocated with either rMalloc, rCalloc or rRealloc.  <a href="#ga811bc61478384c58a95488701c4e53f2">More...</a><br /></td></tr>
<tr class="separator:ga811bc61478384c58a95488701c4e53f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1fb52943b41948ff6900814219cf7c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="R__RTOS__inc_8h.html#aa72989791cb0897faf8ff36202a4e07f">RetCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#gaa1fb52943b41948ff6900814219cf7c9">memMngr_CreateMemPool</a> (const <a class="el" href="R__RTOS__inc_8h.html#ac9a1d73dc119532df42abb4a69b2aa1e">MemSize</a> sizeOfElements, const uint8_t elements, <a class="el" href="group__bestBuddyAlloc.html#ga45bb5f14f010053b22d49b81e127e49c">MemPoolID</a> *const memPoolID)</td></tr>
<tr class="memdesc:gaa1fb52943b41948ff6900814219cf7c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a memory pool with the given <a class="el" href="group__bestBuddyAlloc.html#ga45bb5f14f010053b22d49b81e127e49c" title="8Bit ID value of a memory pool. ">MemPoolID</a>.  <a href="#gaa1fb52943b41948ff6900814219cf7c9">More...</a><br /></td></tr>
<tr class="separator:gaa1fb52943b41948ff6900814219cf7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac435f0029ea8782a3e0328eb3bf34915"><td class="memItemLeft" align="right" valign="top"><a class="el" href="R__RTOS__inc_8h.html#aa72989791cb0897faf8ff36202a4e07f">RetCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#gac435f0029ea8782a3e0328eb3bf34915">memMngr_DeleteMemPool</a> (const <a class="el" href="group__bestBuddyAlloc.html#ga45bb5f14f010053b22d49b81e127e49c">MemPoolID</a> memPoolID)</td></tr>
<tr class="memdesc:gac435f0029ea8782a3e0328eb3bf34915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a previously created memory pool linked to the provided MemPoolID.  <a href="#gac435f0029ea8782a3e0328eb3bf34915">More...</a><br /></td></tr>
<tr class="separator:gac435f0029ea8782a3e0328eb3bf34915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4341fd15424f71884ca0838fc43a4488"><td class="memItemLeft" align="right" valign="top"><a class="el" href="R__RTOS__inc_8h.html#aa72989791cb0897faf8ff36202a4e07f">RetCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#ga4341fd15424f71884ca0838fc43a4488">memMngr_MemPoolMalloc</a> (void **ptrToMem, const <a class="el" href="group__bestBuddyAlloc.html#ga45bb5f14f010053b22d49b81e127e49c">MemPoolID</a> memPoolID)</td></tr>
<tr class="memdesc:ga4341fd15424f71884ca0838fc43a4488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an element from the memory pool specified by the provided MemPoolID.  <a href="#ga4341fd15424f71884ca0838fc43a4488">More...</a><br /></td></tr>
<tr class="separator:ga4341fd15424f71884ca0838fc43a4488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa29f38763ba1fe484e9041825b0141f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="R__RTOS__inc_8h.html#aa72989791cb0897faf8ff36202a4e07f">RetCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#gafa29f38763ba1fe484e9041825b0141f">memMngr_MemPoolFree</a> (void *ptrToMem, const <a class="el" href="group__bestBuddyAlloc.html#ga45bb5f14f010053b22d49b81e127e49c">MemPoolID</a> memPoolID)</td></tr>
<tr class="memdesc:gafa29f38763ba1fe484e9041825b0141f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a previously allocated block of memory from a memory pool and put it back into the memory pool.  <a href="#gafa29f38763ba1fe484e9041825b0141f">More...</a><br /></td></tr>
<tr class="separator:gafa29f38763ba1fe484e9041825b0141f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga1e2c5c4856d56b40b60d0be9741ff390"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#ga1e2c5c4856d56b40b60d0be9741ff390">freeMemLst</a> = (<a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *) <a class="el" href="R__RTOS__inc_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></td></tr>
<tr class="memdesc:ga1e2c5c4856d56b40b60d0be9741ff390"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of free blocks of memory.  <a href="#ga1e2c5c4856d56b40b60d0be9741ff390">More...</a><br /></td></tr>
<tr class="separator:ga1e2c5c4856d56b40b60d0be9741ff390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga020442cc1ea741f7d54df520da4d9cd1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#ga020442cc1ea741f7d54df520da4d9cd1">objCache</a> = (<a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *) <a class="el" href="R__RTOS__inc_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></td></tr>
<tr class="memdesc:ga020442cc1ea741f7d54df520da4d9cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of free cached blocks of memory.  <a href="#ga020442cc1ea741f7d54df520da4d9cd1">More...</a><br /></td></tr>
<tr class="separator:ga020442cc1ea741f7d54df520da4d9cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d4743af777c837eceb4bbe7121e5adc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#ga4d4743af777c837eceb4bbe7121e5adc">objCacheEnd</a> = (<a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *) <a class="el" href="R__RTOS__inc_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></td></tr>
<tr class="memdesc:ga4d4743af777c837eceb4bbe7121e5adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of the objCache List.  <a href="#ga4d4743af777c837eceb4bbe7121e5adc">More...</a><br /></td></tr>
<tr class="separator:ga4d4743af777c837eceb4bbe7121e5adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga676c7e6579ccf6d2456accdd6e9aa5f5"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#ga676c7e6579ccf6d2456accdd6e9aa5f5">buddyOffset</a> = (uint8_t) 0x0u</td></tr>
<tr class="memdesc:ga676c7e6579ccf6d2456accdd6e9aa5f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory address offset of buddy blocks.  <a href="#ga676c7e6579ccf6d2456accdd6e9aa5f5">More...</a><br /></td></tr>
<tr class="separator:ga676c7e6579ccf6d2456accdd6e9aa5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa483a6d5225cf474c6d1a3ad97e0d662"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bestBuddyAlloc.html#gaa483a6d5225cf474c6d1a3ad97e0d662">cacheSize</a> = (uint8_t) 0x0u</td></tr>
<tr class="memdesc:gaa483a6d5225cf474c6d1a3ad97e0d662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter for the current size of the objCache.  <a href="#gaa483a6d5225cf474c6d1a3ad97e0d662">More...</a><br /></td></tr>
<tr class="separator:gaa483a6d5225cf474c6d1a3ad97e0d662"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Modified Best Buddy Memory Allocator. </p>
<p>Modified -&gt; Can use adjacent blocks to fit memory needs -&gt; reduce internal fragmentation</p>
<p>Object Cache -&gt; Objects are put into an object cache upon freeing them -&gt; alleviates frequent allocations of same-size objects </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gac6fbf92ebf7fa6ce06aec092d6b02393"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIGGEST_BLCK&#160;&#160;&#160;((<a class="el" href="group__bestBuddyAlloc.html#ga344bd71f9b6293a6f87a7c58de364fe8">BlckSize</a>)0x100u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of the biggest possible buddy. </p>
<p>Restricted by the usage of flags. </p>

</div>
</div>
<a class="anchor" id="ga9df40dd9c205133d63a595febb7149a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIGGEST_BLCK_MSK&#160;&#160;&#160;((<a class="el" href="group__bestBuddyAlloc.html#ga344bd71f9b6293a6f87a7c58de364fe8">BlckSize</a>)(<a class="el" href="group__bestBuddyAlloc.html#gac6fbf92ebf7fa6ce06aec092d6b02393">BIGGEST_BLCK</a> - (<a class="el" href="group__bestBuddyAlloc.html#ga344bd71f9b6293a6f87a7c58de364fe8">BlckSize</a>)1u))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask for blocks bigger than BIGGER_BLCK. </p>
<p>Restricted by the maximum size of the MemMngrHead. </p>

</div>
</div>
<a class="anchor" id="ga8a6befd630ea1c2ab260266f7466540c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CACHE_SIZE&#160;&#160;&#160;((uint8_t)0x10u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of the object cache. </p>
<p>When an object is freed it is not directly inserted back into the free list. It is rather held in the object cache until the cache is full. FIFO principle is applied. </p>

</div>
</div>
<a class="anchor" id="gadf59e67b443ce5f091d7c9b6be66db1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SMALLER_BLCK_DIVISOR&#160;&#160;&#160;(<a class="el" href="group__bestBuddyAlloc.html#gab59fbcd8b7379f49357e6f3ee03fd623">MemIndex</a>)(0x3u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit shifts needed for a division through SMALLEST_BLCK. </p>
<dl class="section note"><dt>Note</dt><dd>log2(SMALLEST_BLCK). </dd></dl>

</div>
</div>
<a class="anchor" id="ga9fa793b67a572377552189c6a7765185"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SMALLER_BLCK_MSK&#160;&#160;&#160;((<a class="el" href="group__bestBuddyAlloc.html#ga344bd71f9b6293a6f87a7c58de364fe8">BlckSize</a>)(<a class="el" href="group__bestBuddyAlloc.html#ga359dc7027f36b533d6a4e00cb9be1287">SMALLEST_BLCK</a> - (<a class="el" href="group__bestBuddyAlloc.html#ga344bd71f9b6293a6f87a7c58de364fe8">BlckSize</a>)1u))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask for blocks smaller than SMALLEST_BLCK. </p>
<p>Restricted by the minimum size of the MemMngrHead. </p>

</div>
</div>
<a class="anchor" id="ga359dc7027f36b533d6a4e00cb9be1287"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SMALLEST_BLCK&#160;&#160;&#160;((<a class="el" href="group__bestBuddyAlloc.html#ga344bd71f9b6293a6f87a7c58de364fe8">BlckSize</a>)0x8u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of the smallest possible buddy. </p>
<p>Restricted by the minimum size of the MemMngrHead. </p><dl class="section note"><dt>Note</dt><dd>Has to be a power of two. </dd>
<dd>
Has to be at least the size of a MemMngrHead struct. </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga6ec0ea53f55f2ecffcafffdc7a0df532"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bestBuddyAlloc.html#ga6ec0ea53f55f2ecffcafffdc7a0df532">stdPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple void pointer. </p>
<p>Might be deprecated. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga2abedb3bd0e43ce448ea9b82ef8f5347"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void addBlckToCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const&#160;</td>
          <td class="paramname"><em>blckToAdd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the given block to the objCache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blckToAdd</td><td>Pointer to the block to add to the cache.</td></tr>
  </table>
  </dd>
</dl>
<p>Adds the given block to the beginning of the objCache. Check if the object is not already cached to avoid a loop in the cache! Also check the cacheSize and shrink the cache if it is bigger than the specified CACHE_SIZE. </p>

</div>
</div>
<a class="anchor" id="ga359c3d7d5c206729eeb7ae10b382e5bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void delMemBlck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const&#160;</td>
          <td class="paramname"><em>blckToDelete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete a block from the list it is contained in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blckToDelete</td><td>Pointer to the block which shall be deleted from its list.</td></tr>
  </table>
  </dd>
</dl>
<p>Adjusts the ptrNXT and ptrPREV of the block as well as the next and previous block's pointers. </p>

</div>
</div>
<a class="anchor" id="ga7c8770718e6aa3266f716d039806d1cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fitBlckBackIntoFreeLst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const&#160;</td>
          <td class="paramname"><em>curBlck</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put the given block back into the free memory blocks list according to its address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">curBlck</td><td>Pointer to the block to be reinserted into the free memory blocks list.</td></tr>
  </table>
  </dd>
</dl>
<p>The next and previous free block of memory is calculated. The ptrNXT and ptrPREV of these and the curBlck are adjusted accordingly. The start of the freeMemLst is adjusted if there is no free previous block of memory. </p>

</div>
</div>
<a class="anchor" id="ga8756c9ebce613b7cd9224a54b2e9100a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> * getAdjacentNxtBlck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const&#160;</td>
          <td class="paramname"><em>curBlck</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate and return the block next to the given block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">curBlck</td><td>Pointer to the block to return the successor to.</td></tr>
  </table>
  </dd>
</dl>
<p>Using the saved size of the curBlck ( in flagsForMemBlock ) the next block is calculated, casted to MemMngrHead * and returned. </p>

</div>
</div>
<a class="anchor" id="gaae3a581fb679a9ed0df58140874d43ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> * getAdjacentPrevBlck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const&#160;</td>
          <td class="paramname"><em>curBlck</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate and return the block prior to the given block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">curBlck</td><td>Pointer to the block to return the predecessor to.</td></tr>
  </table>
  </dd>
</dl>
<p>Using the saved size of the previous block ( in additionalFlags ) the previous block is calculated, casted to MemMngrHead * and returned. </p>

</div>
</div>
<a class="anchor" id="ga3d6be2a4fa01e852b26426b480d69d02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> * getBuddyBlck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const&#160;</td>
          <td class="paramname"><em>curBlck</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate and return the buddy block to the given block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">curBlck</td><td>Pointer to the block to return the buddy block to.</td></tr>
  </table>
  </dd>
</dl>
<p>Using the buddyOffset the address of curBlck is XORed with the block's size to get its buddy block. The result is casted to MemMngrHead and returned.</p>
<dl class="section warning"><dt>Warning</dt><dd>DO NOT USE THE BUDDY BLOCK, AS IT IS NOT GUARANTEED, THAT THE BLOCK IS FREE. NOR IS THERE ANY GUARANTEE, THAT THE BLOCK IS NOT INSIDE OF A COMBINATION OF BLOCKS. USE ONLY THE ADDRESS! </dd></dl>

</div>
</div>
<a class="anchor" id="ga369bb7fea11c364989320098b5499651"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="R__RTOS__inc_8h.html#aa72989791cb0897faf8ff36202a4e07f">RetCode</a> initMEM </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the memory manager. </p>
<dl class="section return"><dt>Returns</dt><dd>Return the success of the operation.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>MUST BE CALLED BEFORE ANY CALL TO A MEMORY MANAGER RELATED FUNCTION! </dd></dl>

</div>
</div>
<a class="anchor" id="gaa1fb52943b41948ff6900814219cf7c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="R__RTOS__inc_8h.html#aa72989791cb0897faf8ff36202a4e07f">RetCode</a> memMngr_CreateMemPool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="R__RTOS__inc_8h.html#ac9a1d73dc119532df42abb4a69b2aa1e">MemSize</a>&#160;</td>
          <td class="paramname"><em>sizeOfElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bestBuddyAlloc.html#ga45bb5f14f010053b22d49b81e127e49c">MemPoolID</a> *const&#160;</td>
          <td class="paramname"><em>memPoolID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a memory pool with the given <a class="el" href="group__bestBuddyAlloc.html#ga45bb5f14f010053b22d49b81e127e49c" title="8Bit ID value of a memory pool. ">MemPoolID</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sizeOfElements</td><td>Size of one element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elements</td><td>Number of elements to allocate the pool for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">memPoolID</td><td>Pointer to a <a class="el" href="group__bestBuddyAlloc.html#ga45bb5f14f010053b22d49b81e127e49c" title="8Bit ID value of a memory pool. ">MemPoolID</a> that receives the ID of the created memory pool</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the success of the operation</dd></dl>
<p>This function allocates elements number of memory block with the size sizeOfElements and assigns its <a class="el" href="group__bestBuddyAlloc.html#ga45bb5f14f010053b22d49b81e127e49c" title="8Bit ID value of a memory pool. ">MemPoolID</a> to memPoolID.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function must have been called before the memory pool can be used! </dd></dl>

</div>
</div>
<a class="anchor" id="gac435f0029ea8782a3e0328eb3bf34915"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="R__RTOS__inc_8h.html#aa72989791cb0897faf8ff36202a4e07f">RetCode</a> memMngr_DeleteMemPool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bestBuddyAlloc.html#ga45bb5f14f010053b22d49b81e127e49c">MemPoolID</a>&#160;</td>
          <td class="paramname"><em>memPoolID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a previously created memory pool linked to the provided MemPoolID. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Implement! </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>DO NOT USE! </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">memPoolID</td><td>Memory pool ID of the memory pool to be deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the success of the operation </dd></dl>

</div>
</div>
<a class="anchor" id="gafa29f38763ba1fe484e9041825b0141f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="R__RTOS__inc_8h.html#aa72989791cb0897faf8ff36202a4e07f">RetCode</a> memMngr_MemPoolFree </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptrToMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__bestBuddyAlloc.html#ga45bb5f14f010053b22d49b81e127e49c">MemPoolID</a>&#160;</td>
          <td class="paramname"><em>memPoolID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a previously allocated block of memory from a memory pool and put it back into the memory pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptrToMem</td><td>Pointer to the block of memory to free </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memPoolID</td><td><a class="el" href="group__bestBuddyAlloc.html#ga45bb5f14f010053b22d49b81e127e49c" title="8Bit ID value of a memory pool. ">MemPoolID</a> of the memory pool the block of memory was allocated from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the success of the operation</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The block must have been allocated from the memory pool corresponding to the given MemPoolID! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The block is prepended to the memory pool's available block list. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4341fd15424f71884ca0838fc43a4488"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="R__RTOS__inc_8h.html#aa72989791cb0897faf8ff36202a4e07f">RetCode</a> memMngr_MemPoolMalloc </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>ptrToMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__bestBuddyAlloc.html#ga45bb5f14f010053b22d49b81e127e49c">MemPoolID</a>&#160;</td>
          <td class="paramname"><em>memPoolID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate an element from the memory pool specified by the provided MemPoolID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ptrToMem</td><td>Pointer to pointer that will receive the address of the allocated block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memPoolID</td><td><a class="el" href="group__bestBuddyAlloc.html#ga45bb5f14f010053b22d49b81e127e49c" title="8Bit ID value of a memory pool. ">MemPoolID</a> of the memory pool to allocate the block of memory from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the success of the operation</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The memory pool must have been initialized upfront! </dd></dl>

</div>
</div>
<a class="anchor" id="ga68b69c7cf2857ba17ceaa63769baa560"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t mergeMemBlck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> **&#160;</td>
          <td class="paramname"><em>blckToMerge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The given memory block is merged with its buddy block if it is free and not cached. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blckToMerge</td><td>Pointer to a pointer to the block to be merged.</td></tr>
  </table>
  </dd>
</dl>
<p>The next and previous free block of memory is calculated. The ptrNXT and ptrPREV of these and the curBlck are adjusted accordingly. The start of the freeMemLst is adjusted if there is no free previous block of memory. </p>

</div>
</div>
<a class="anchor" id="ga7215e3278b6a85128484aa16a849b4a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mergeUnevenBlocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const&#160;</td>
          <td class="paramname"><em>added</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The two given memory blocks of unequal size are merged into one memory block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">basis</td><td>Pointer to the block to be merged and used as the pointer to the combined memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">added</td><td>Pointer to the block to be merged with the basis.</td></tr>
  </table>
  </dd>
</dl>
<p>Two blocks of unequal size are merged to make up a new extraordinary sized block. Usually blocks are either split equally or merged with buddies (of the same size so to speak). In order to ease the impact of internal fragmentation, a block can be merged with only parts of its buddy. Flags and sizes of the buddies and the preceding as well as succeeding blocks are adjusted automatically.</p>
<p>Example:</p>
<p>Requested size: 0xC4<br />
 Next bigger block: 0x100<br />
 Next smaller block: 0x80<br />
 Loss: 0x20<br />
</p>
<p>Therefore split bigger block ( to 0x80) and add the remaining need from its ( again split) buddy (0x40). If the size is insufficient the process can be repeated. Again add a split buddy (0x10) to suffice the need best fitting (0xD0)</p>
<p>Requested size: 0xC4<br />
 Next bigger block: 0x100<br />
 Split once: 0x80<br />
 Remainder: 0x44<br />
 Split buddy: 0x40<br />
 Remainder: 0x4<br />
 Split buddy best fit: 0x10<br />
 Combined size: 0xD0<br />
 Loss: 0xC<br />
 SAVED: 0x14<br />
 </p>

</div>
</div>
<a class="anchor" id="gad0512fc8c659f4685efe22e93cb3b9fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * rCalloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="R__RTOS__inc_8h.html#ac9a1d73dc119532df42abb4a69b2aa1e">MemSize</a>&#160;</td>
          <td class="paramname"><em>desiredSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>DO NOT USE, UNFINISHED </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desiredSize</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>UNTESTED! </dd></dl>

</div>
</div>
<a class="anchor" id="gad70561f8e55c5019589d8ef867b539b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void reMergeMemBlck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> **&#160;</td>
          <td class="paramname"><em>blckToMerge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The given memory block is merged continuously with its buddy blocks as long as these are neither taken nor cached. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blckToMerge</td><td>Pointer to a pointer to the block to be merged.</td></tr>
  </table>
  </dd>
</dl>
<p>Using mergeMemBlck a Block is merged to its biggest possible size with is free and uncached buddies. </p>

</div>
</div>
<a class="anchor" id="gae3783e27f134ba0fcd5d95ff9506e722"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rFree </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pToBeFreed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The provided block of memory will be added to the memory block cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pToBeFreed</td><td>[in] Pointer to the block of memory to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga811bc61478384c58a95488701c4e53f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rFullyFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *&#160;</td>
          <td class="paramname"><em>blckToFullyFree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a block of memory previously allocated with either rMalloc, rCalloc or rRealloc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blckToFullyFree</td><td>[in] Pointer to the block of memory (<a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f" title="memMngrHead ">MemMngrHead</a>) to free and put back onto the free memory blocks list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa413533dce906197feee17e35a9d78e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * rMalloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="R__RTOS__inc_8h.html#ac9a1d73dc119532df42abb4a69b2aa1e">MemSize</a>&#160;</td>
          <td class="paramname"><em>desiredSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a block of memory satisfying the desiredSize property. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desiredSize</td><td>[in] The size of the memory block needed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6c4582e0c129b415d6d5bf7753f8a30c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * rRealloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptrToExistingMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="R__RTOS__inc_8h.html#ac9a1d73dc119532df42abb4a69b2aa1e">MemSize</a>&#160;</td>
          <td class="paramname"><em>desiredSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a block of memory satisfying the desiredSize property. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrToExistingMem</td><td>[in, out] Pointer to the already allocated memory. </td></tr>
    <tr><td class="paramname">desiredSize</td><td>[in] The size of the memory block needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>UNTESTED! </dd></dl>

</div>
</div>
<a class="anchor" id="ga61407be52d8b17c8e4a0a353a23aaa8b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void shrinkCacheFIFO </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the last element out of the cache. </p>
<p>Simply removes the last element of the objCache and sets the new list end accordingly. </p>

</div>
</div>
<a class="anchor" id="ga7289114e196270ab93c5dda852b324a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void splitMemBlck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> **const&#160;</td>
          <td class="paramname"><em>blckToSplit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The given memory block is split into two equally sized buddies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blckToSplit</td><td>Pointer to a pointer to the block to be split.</td></tr>
  </table>
  </dd>
</dl>
<p>The given block of memory is split in half. The flags of both blocks are adjusted accordingly. </p>

</div>
</div>
<a class="anchor" id="ga2a92216fae1dd09795d592eab2bc28c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void unMergeUnevenBlcks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const&#160;</td>
          <td class="paramname"><em>blckToUnMerge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The given memory block is split into the unequal buddy blocks it consisted of. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blckToUnMerge</td><td>Pointer to the block to be unmerged.</td></tr>
  </table>
  </dd>
</dl>
<p>A block can be made up of unequally sized buddies. This function extracts these buddies and adds them back to the freeMemLst. Flags and sizes of the buddies and the preceding as well as succeeding blocks are adjusted automatically. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga676c7e6579ccf6d2456accdd6e9aa5f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">buddyOffset = (uint8_t) 0x0u</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Memory address offset of buddy blocks. </p>
<p>In order to be able to XOR the address of a block with its size and get its buddy, addresses have to be altered with an offset beforehand.</p>
<p>E.g.:<br />
 Actual address: 0x1ffff38<br />
 Offset: 0x8<br />
 Possible size: 0x20<br />
 Buddy block = ( (0x1ffff38 - 0x8) ^ 0x20 ) + 0x8</p>
<p>Initialized to 0x0. </p>

</div>
</div>
<a class="anchor" id="gaa483a6d5225cf474c6d1a3ad97e0d662"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cacheSize = (uint8_t) 0x0u</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counter for the current size of the objCache. </p>
<p>Keeps track of the elements in the objCache. Decreases and increases automatically when objects are added, removed or kicked out.</p>
<p>Initialized to 0x0. </p>

</div>
</div>
<a class="anchor" id="ga1e2c5c4856d56b40b60d0be9741ff390"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">freeMemLst = (<a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *) <a class="el" href="R__RTOS__inc_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of free blocks of memory. </p>
<p>Contains free blocks of memory that are not cached.</p>
<p>Initialized to NULL. </p>

</div>
</div>
<a class="anchor" id="ga020442cc1ea741f7d54df520da4d9cd1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">objCache = (<a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *) <a class="el" href="R__RTOS__inc_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of free cached blocks of memory. </p>
<p>As soon as a block of memory is freed it is added to the objCache. The size of the obCache is define by CACHE_SIZE. If the size exceeds this limit elements are removed according to FIFO principle.</p>
<p>Initialized to NULL. </p>

</div>
</div>
<a class="anchor" id="ga4d4743af777c837eceb4bbe7121e5adc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">objCacheEnd = (<a class="el" href="group__bestBuddyAlloc.html#ga060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *) <a class="el" href="R__RTOS__inc_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End of the objCache List. </p>
<p>The last element in the object cache.</p>
<p>Initialized to NULL. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
