<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>R_RTOS: R_RTOS_memMngr.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">R_RTOS
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">DistributedRealTimeOperatingSystemfortheARMCortexMArchitecture</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_r___r_t_o_s__mem_mngr_8c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">R_RTOS_memMngr.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions for creating, initializing, maintaining and handling a task timers.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="_r___r_t_o_s__mem_mngr_8h_source.html">R_RTOS_memMngr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_r___r_t_o_s___bit_magic_8h_source.html">R_RTOS_BitMagic.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a369bb7fea11c364989320098b5499651"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_r___r_t_o_s__inc_8h.html#ae652fbd48bfccbcc4f573e8d45529404">RetCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r___r_t_o_s__mem_mngr_8c.html#a369bb7fea11c364989320098b5499651">initMEM</a> (void)</td></tr>
<tr class="memdesc:a369bb7fea11c364989320098b5499651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the memory manager.  <a href="#a369bb7fea11c364989320098b5499651">More...</a><br /></td></tr>
<tr class="separator:a369bb7fea11c364989320098b5499651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359c3d7d5c206729eeb7ae10b382e5bd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r___r_t_o_s__mem_mngr_8c.html#a359c3d7d5c206729eeb7ae10b382e5bd">delMemBlck</a> (<a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const blckToDelete)</td></tr>
<tr class="memdesc:a359c3d7d5c206729eeb7ae10b382e5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a block from the list it is contained in.  <a href="#a359c3d7d5c206729eeb7ae10b382e5bd">More...</a><br /></td></tr>
<tr class="separator:a359c3d7d5c206729eeb7ae10b382e5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3a581fb679a9ed0df58140874d43ad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r___r_t_o_s__mem_mngr_8c.html#aae3a581fb679a9ed0df58140874d43ad">getAdjacentPrevBlck</a> (<a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const curBlck)</td></tr>
<tr class="memdesc:aae3a581fb679a9ed0df58140874d43ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate and return the block prior to the given block.  <a href="#aae3a581fb679a9ed0df58140874d43ad">More...</a><br /></td></tr>
<tr class="separator:aae3a581fb679a9ed0df58140874d43ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8756c9ebce613b7cd9224a54b2e9100a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r___r_t_o_s__mem_mngr_8c.html#a8756c9ebce613b7cd9224a54b2e9100a">getAdjacentNxtBlck</a> (<a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const curBlck)</td></tr>
<tr class="memdesc:a8756c9ebce613b7cd9224a54b2e9100a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate and return the block next to the given block.  <a href="#a8756c9ebce613b7cd9224a54b2e9100a">More...</a><br /></td></tr>
<tr class="separator:a8756c9ebce613b7cd9224a54b2e9100a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6be2a4fa01e852b26426b480d69d02"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r___r_t_o_s__mem_mngr_8c.html#a3d6be2a4fa01e852b26426b480d69d02">getBuddyBlck</a> (<a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const curBlck)</td></tr>
<tr class="memdesc:a3d6be2a4fa01e852b26426b480d69d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate and return the buddy block to the given block.  <a href="#a3d6be2a4fa01e852b26426b480d69d02">More...</a><br /></td></tr>
<tr class="separator:a3d6be2a4fa01e852b26426b480d69d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8770718e6aa3266f716d039806d1cd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r___r_t_o_s__mem_mngr_8c.html#a7c8770718e6aa3266f716d039806d1cd">fitBlckBackIntoFreeLst</a> (<a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const curBlck)</td></tr>
<tr class="memdesc:a7c8770718e6aa3266f716d039806d1cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the given block back into the free memory blocks list according to its address.  <a href="#a7c8770718e6aa3266f716d039806d1cd">More...</a><br /></td></tr>
<tr class="separator:a7c8770718e6aa3266f716d039806d1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b69c7cf2857ba17ceaa63769baa560"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r___r_t_o_s__mem_mngr_8c.html#a68b69c7cf2857ba17ceaa63769baa560">mergeMemBlck</a> (<a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> **blckToMerge)</td></tr>
<tr class="memdesc:a68b69c7cf2857ba17ceaa63769baa560"><td class="mdescLeft">&#160;</td><td class="mdescRight">The given memory block is merged with its buddy block if it is free and not cached.  <a href="#a68b69c7cf2857ba17ceaa63769baa560">More...</a><br /></td></tr>
<tr class="separator:a68b69c7cf2857ba17ceaa63769baa560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70561f8e55c5019589d8ef867b539b5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r___r_t_o_s__mem_mngr_8c.html#ad70561f8e55c5019589d8ef867b539b5">reMergeMemBlck</a> (<a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> **blckToMerge)</td></tr>
<tr class="memdesc:ad70561f8e55c5019589d8ef867b539b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The given memory block is merged continuously with its buddy blocks as long as these are neither taken nor cached.  <a href="#ad70561f8e55c5019589d8ef867b539b5">More...</a><br /></td></tr>
<tr class="separator:ad70561f8e55c5019589d8ef867b539b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7289114e196270ab93c5dda852b324a2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r___r_t_o_s__mem_mngr_8c.html#a7289114e196270ab93c5dda852b324a2">splitMemBlck</a> (<a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> **const blckToSplit)</td></tr>
<tr class="memdesc:a7289114e196270ab93c5dda852b324a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The given memory block is split into two equally sized buddies.  <a href="#a7289114e196270ab93c5dda852b324a2">More...</a><br /></td></tr>
<tr class="separator:a7289114e196270ab93c5dda852b324a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a92216fae1dd09795d592eab2bc28c6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r___r_t_o_s__mem_mngr_8c.html#a2a92216fae1dd09795d592eab2bc28c6">unMergeUnevenBlcks</a> (<a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const blckToUnMerge)</td></tr>
<tr class="memdesc:a2a92216fae1dd09795d592eab2bc28c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The given memory block is split into the unequal buddy blocks it consisted of.  <a href="#a2a92216fae1dd09795d592eab2bc28c6">More...</a><br /></td></tr>
<tr class="separator:a2a92216fae1dd09795d592eab2bc28c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7215e3278b6a85128484aa16a849b4a7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r___r_t_o_s__mem_mngr_8c.html#a7215e3278b6a85128484aa16a849b4a7">mergeUnevenBlocks</a> (<a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const basis, <a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const added)</td></tr>
<tr class="memdesc:a7215e3278b6a85128484aa16a849b4a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The two given memory blocks of unequal size are merged into one memory block.  <a href="#a7215e3278b6a85128484aa16a849b4a7">More...</a><br /></td></tr>
<tr class="separator:a7215e3278b6a85128484aa16a849b4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61407be52d8b17c8e4a0a353a23aaa8b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r___r_t_o_s__mem_mngr_8c.html#a61407be52d8b17c8e4a0a353a23aaa8b">shrinkCacheFIFO</a> (void)</td></tr>
<tr class="memdesc:a61407be52d8b17c8e4a0a353a23aaa8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the last element out of the cache.  <a href="#a61407be52d8b17c8e4a0a353a23aaa8b">More...</a><br /></td></tr>
<tr class="separator:a61407be52d8b17c8e4a0a353a23aaa8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2abedb3bd0e43ce448ea9b82ef8f5347"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r___r_t_o_s__mem_mngr_8c.html#a2abedb3bd0e43ce448ea9b82ef8f5347">addBlckToCache</a> (<a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const blckToAdd)</td></tr>
<tr class="memdesc:a2abedb3bd0e43ce448ea9b82ef8f5347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the given block to the objCache.  <a href="#a2abedb3bd0e43ce448ea9b82ef8f5347">More...</a><br /></td></tr>
<tr class="separator:a2abedb3bd0e43ce448ea9b82ef8f5347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d95a879ac03cd989750357490f657a9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r___r_t_o_s__mem_mngr_8c.html#a6d95a879ac03cd989750357490f657a9">rMalloc</a> (const <a class="el" href="_r___r_t_o_s__inc_8h.html#aabeb94fe480b56f48c0a3b3e977d3066">MemSize</a> desiredSize)</td></tr>
<tr class="memdesc:a6d95a879ac03cd989750357490f657a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block of memory satisfying the desiredSize property.  <a href="#a6d95a879ac03cd989750357490f657a9">More...</a><br /></td></tr>
<tr class="separator:a6d95a879ac03cd989750357490f657a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36b050e66e4905bf64029d54ef3bb56"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r___r_t_o_s__mem_mngr_8c.html#af36b050e66e4905bf64029d54ef3bb56">rCalloc</a> (const <a class="el" href="_r___r_t_o_s__inc_8h.html#aabeb94fe480b56f48c0a3b3e977d3066">MemSize</a> desiredSize)</td></tr>
<tr class="separator:af36b050e66e4905bf64029d54ef3bb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21510e924ac77671906169b30c0da628"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r___r_t_o_s__mem_mngr_8c.html#a21510e924ac77671906169b30c0da628">rRealloc</a> (void *const ptrToExistingMem, const <a class="el" href="_r___r_t_o_s__inc_8h.html#aabeb94fe480b56f48c0a3b3e977d3066">MemSize</a> desiredSize)</td></tr>
<tr class="memdesc:a21510e924ac77671906169b30c0da628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block of memory satisfying the desiredSize property.  <a href="#a21510e924ac77671906169b30c0da628">More...</a><br /></td></tr>
<tr class="separator:a21510e924ac77671906169b30c0da628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12eb126ae45b5e069a7d73871cce534"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r___r_t_o_s__mem_mngr_8c.html#ae12eb126ae45b5e069a7d73871cce534">rFree</a> (void *const pToBeFreed)</td></tr>
<tr class="memdesc:ae12eb126ae45b5e069a7d73871cce534"><td class="mdescLeft">&#160;</td><td class="mdescRight">The provided block of memory will be added to the memory block cache.  <a href="#ae12eb126ae45b5e069a7d73871cce534">More...</a><br /></td></tr>
<tr class="separator:ae12eb126ae45b5e069a7d73871cce534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811bc61478384c58a95488701c4e53f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r___r_t_o_s__mem_mngr_8c.html#a811bc61478384c58a95488701c4e53f2">rFullyFree</a> (<a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *blckToFullyFree)</td></tr>
<tr class="memdesc:a811bc61478384c58a95488701c4e53f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a block of memory previously allocated with either rMalloc, rCalloc or rRealloc.  <a href="#a811bc61478384c58a95488701c4e53f2">More...</a><br /></td></tr>
<tr class="separator:a811bc61478384c58a95488701c4e53f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1fb52943b41948ff6900814219cf7c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_r___r_t_o_s__inc_8h.html#ae652fbd48bfccbcc4f573e8d45529404">RetCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r___r_t_o_s__mem_mngr_8c.html#aa1fb52943b41948ff6900814219cf7c9">memMngr_CreateMemPool</a> (const <a class="el" href="_r___r_t_o_s__inc_8h.html#aabeb94fe480b56f48c0a3b3e977d3066">MemSize</a> sizeOfElements, const uint8_t elements, <a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a45bb5f14f010053b22d49b81e127e49c">MemPoolID</a> *const memPoolID)</td></tr>
<tr class="separator:aa1fb52943b41948ff6900814219cf7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac435f0029ea8782a3e0328eb3bf34915"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_r___r_t_o_s__inc_8h.html#ae652fbd48bfccbcc4f573e8d45529404">RetCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r___r_t_o_s__mem_mngr_8c.html#ac435f0029ea8782a3e0328eb3bf34915">memMngr_DeleteMemPool</a> (const <a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a45bb5f14f010053b22d49b81e127e49c">MemPoolID</a> memPoolID)</td></tr>
<tr class="memdesc:ac435f0029ea8782a3e0328eb3bf34915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a previously created memory pool linked to the provided MemPoolID.  <a href="#ac435f0029ea8782a3e0328eb3bf34915">More...</a><br /></td></tr>
<tr class="separator:ac435f0029ea8782a3e0328eb3bf34915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4341fd15424f71884ca0838fc43a4488"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_r___r_t_o_s__inc_8h.html#ae652fbd48bfccbcc4f573e8d45529404">RetCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r___r_t_o_s__mem_mngr_8c.html#a4341fd15424f71884ca0838fc43a4488">memMngr_MemPoolMalloc</a> (void **ptrToMem, const <a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a45bb5f14f010053b22d49b81e127e49c">MemPoolID</a> memPoolID)</td></tr>
<tr class="memdesc:a4341fd15424f71884ca0838fc43a4488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an element from the memory pool specified by the provided MemPoolID.  <a href="#a4341fd15424f71884ca0838fc43a4488">More...</a><br /></td></tr>
<tr class="separator:a4341fd15424f71884ca0838fc43a4488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa29f38763ba1fe484e9041825b0141f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_r___r_t_o_s__inc_8h.html#ae652fbd48bfccbcc4f573e8d45529404">RetCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r___r_t_o_s__mem_mngr_8c.html#afa29f38763ba1fe484e9041825b0141f">memMngr_MemPoolFree</a> (void *ptrToMem, const <a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a45bb5f14f010053b22d49b81e127e49c">MemPoolID</a> memPoolID)</td></tr>
<tr class="separator:afa29f38763ba1fe484e9041825b0141f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a1e2c5c4856d56b40b60d0be9741ff390"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r___r_t_o_s__mem_mngr_8c.html#a1e2c5c4856d56b40b60d0be9741ff390">freeMemLst</a> = (<a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *) <a class="el" href="_r___r_t_o_s__inc_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></td></tr>
<tr class="memdesc:a1e2c5c4856d56b40b60d0be9741ff390"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of free blocks of memory.  <a href="#a1e2c5c4856d56b40b60d0be9741ff390">More...</a><br /></td></tr>
<tr class="separator:a1e2c5c4856d56b40b60d0be9741ff390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020442cc1ea741f7d54df520da4d9cd1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r___r_t_o_s__mem_mngr_8c.html#a020442cc1ea741f7d54df520da4d9cd1">objCache</a> = (<a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *) <a class="el" href="_r___r_t_o_s__inc_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></td></tr>
<tr class="memdesc:a020442cc1ea741f7d54df520da4d9cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of free cached blocks of memory.  <a href="#a020442cc1ea741f7d54df520da4d9cd1">More...</a><br /></td></tr>
<tr class="separator:a020442cc1ea741f7d54df520da4d9cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4743af777c837eceb4bbe7121e5adc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r___r_t_o_s__mem_mngr_8c.html#a4d4743af777c837eceb4bbe7121e5adc">objCacheEnd</a> = (<a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *) <a class="el" href="_r___r_t_o_s__inc_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></td></tr>
<tr class="memdesc:a4d4743af777c837eceb4bbe7121e5adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of the objCache List.  <a href="#a4d4743af777c837eceb4bbe7121e5adc">More...</a><br /></td></tr>
<tr class="separator:a4d4743af777c837eceb4bbe7121e5adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676c7e6579ccf6d2456accdd6e9aa5f5"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r___r_t_o_s__mem_mngr_8c.html#a676c7e6579ccf6d2456accdd6e9aa5f5">buddyOffset</a> = (uint8_t) 0x0u</td></tr>
<tr class="memdesc:a676c7e6579ccf6d2456accdd6e9aa5f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory address offset of buddy blocks.  <a href="#a676c7e6579ccf6d2456accdd6e9aa5f5">More...</a><br /></td></tr>
<tr class="separator:a676c7e6579ccf6d2456accdd6e9aa5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa483a6d5225cf474c6d1a3ad97e0d662"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r___r_t_o_s__mem_mngr_8c.html#aa483a6d5225cf474c6d1a3ad97e0d662">cacheSize</a> = (uint8_t) 0x0u</td></tr>
<tr class="memdesc:aa483a6d5225cf474c6d1a3ad97e0d662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter for the current size of the objCache.  <a href="#aa483a6d5225cf474c6d1a3ad97e0d662">More...</a><br /></td></tr>
<tr class="separator:aa483a6d5225cf474c6d1a3ad97e0d662"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Functions for creating, initializing, maintaining and handling a task timers. </p>
<dl class="section author"><dt>Author</dt><dd>Christian Neuberger (<a href="#" onclick="location.href='mai'+'lto:'+'Neu'+'be'+'rge'+'rC'+'h50'+'34'+'4@t'+'h-'+'nue'+'rn'+'ber'+'g.'+'de'; return false;">Neube<span style="display: none;">.nosp@m.</span>rger<span style="display: none;">.nosp@m.</span>Ch503<span style="display: none;">.nosp@m.</span>44@t<span style="display: none;">.nosp@m.</span>h-nue<span style="display: none;">.nosp@m.</span>rnbe<span style="display: none;">.nosp@m.</span>rg.de</a>) </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18.12.2015 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a2abedb3bd0e43ce448ea9b82ef8f5347"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void addBlckToCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const&#160;</td>
          <td class="paramname"><em>blckToAdd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the given block to the objCache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blckToAdd</td><td>Pointer to the block to add to the cache.</td></tr>
  </table>
  </dd>
</dl>
<p>Adds the given block to the beginning of the objCache. Check if the object is not already cached to avoid a loop in the cache! Also check the cacheSize and shrink the cache if it is bigger than the specified CACHE_SIZE. </p>

</div>
</div>
<a class="anchor" id="a359c3d7d5c206729eeb7ae10b382e5bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void delMemBlck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const&#160;</td>
          <td class="paramname"><em>blckToDelete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete a block from the list it is contained in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blckToDelete</td><td>Pointer to the block which shall be deleted from its list.</td></tr>
  </table>
  </dd>
</dl>
<p>Adjusts the ptrNXT and ptrPREV of the block as well as the next and previous block's pointers. </p>

</div>
</div>
<a class="anchor" id="a7c8770718e6aa3266f716d039806d1cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fitBlckBackIntoFreeLst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const&#160;</td>
          <td class="paramname"><em>curBlck</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put the given block back into the free memory blocks list according to its address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">curBlck</td><td>Pointer to the block to be reinserted into the free memory blocks list.</td></tr>
  </table>
  </dd>
</dl>
<p>The next and previous free block of memory is calculated. The ptrNXT and ptrPREV of these and the curBlck are adjusted accordingly. The start of the freeMemLst is adjusted if there is no free previous block of memory. </p>

</div>
</div>
<a class="anchor" id="a8756c9ebce613b7cd9224a54b2e9100a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> * getAdjacentNxtBlck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const&#160;</td>
          <td class="paramname"><em>curBlck</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate and return the block next to the given block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">curBlck</td><td>Pointer to the block to return the successor to.</td></tr>
  </table>
  </dd>
</dl>
<p>Using the saved size of the curBlck ( in flagsForMemBlock ) the next block is calculated, casted to MemMngrHead * and returned. </p>

</div>
</div>
<a class="anchor" id="aae3a581fb679a9ed0df58140874d43ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> * getAdjacentPrevBlck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const&#160;</td>
          <td class="paramname"><em>curBlck</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate and return the block prior to the given block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">curBlck</td><td>Pointer to the block to return the predecessor to.</td></tr>
  </table>
  </dd>
</dl>
<p>Using the saved size of the previous block ( in additionalFlags ) the previous block is calculated, casted to MemMngrHead * and returned. </p>

</div>
</div>
<a class="anchor" id="a3d6be2a4fa01e852b26426b480d69d02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> * getBuddyBlck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const&#160;</td>
          <td class="paramname"><em>curBlck</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate and return the buddy block to the given block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">curBlck</td><td>Pointer to the block to return the buddy block to.</td></tr>
  </table>
  </dd>
</dl>
<p>Using the buddyOffset the address of curBlck is XORed with the block's size to get its buddy block. The result is casted to MemMngrHead and returned.</p>
<dl class="section warning"><dt>Warning</dt><dd>DO NOT USE THE BUDDY BLOCK, AS IT IS NOT GUARANTEED, THAT THE BLOCK IS FREE. NOR IS THERE ANY GUARANTEE, THAT THE BLOCK IS NOT INSIDE OF A COMBINATION OF BLOCKS. USE ONLY THE ADDRESS! </dd></dl>

</div>
</div>
<a class="anchor" id="a369bb7fea11c364989320098b5499651"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_r___r_t_o_s__inc_8h.html#ae652fbd48bfccbcc4f573e8d45529404">RetCode</a> initMEM </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the memory manager. </p>
<dl class="section return"><dt>Returns</dt><dd>Return the success of the operation.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>MUST BE CALLED BEFORE ANY CALL TO A MEMORY MANAGER RELATED FUNCTION! </dd></dl>

</div>
</div>
<a class="anchor" id="aa1fb52943b41948ff6900814219cf7c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_r___r_t_o_s__inc_8h.html#ae652fbd48bfccbcc4f573e8d45529404">RetCode</a> memMngr_CreateMemPool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_r___r_t_o_s__inc_8h.html#aabeb94fe480b56f48c0a3b3e977d3066">MemSize</a>&#160;</td>
          <td class="paramname"><em>sizeOfElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a45bb5f14f010053b22d49b81e127e49c">MemPoolID</a> *const&#160;</td>
          <td class="paramname"><em>memPoolID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sizeOfElements</td><td>Size of one element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elements</td><td>Numer of elements to allocate the pool for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">memPoolID</td><td>Pointer to a MemPoolID that receives the ID of the created memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the success of the operation </dd></dl>

</div>
</div>
<a class="anchor" id="ac435f0029ea8782a3e0328eb3bf34915"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_r___r_t_o_s__inc_8h.html#ae652fbd48bfccbcc4f573e8d45529404">RetCode</a> memMngr_DeleteMemPool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a45bb5f14f010053b22d49b81e127e49c">MemPoolID</a>&#160;</td>
          <td class="paramname"><em>memPoolID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a previously created memory pool linked to the provided MemPoolID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">memPoolID</td><td>Memory pool ID of the memory pool to be deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the success of the operation </dd></dl>

</div>
</div>
<a class="anchor" id="afa29f38763ba1fe484e9041825b0141f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_r___r_t_o_s__inc_8h.html#ae652fbd48bfccbcc4f573e8d45529404">RetCode</a> memMngr_MemPoolFree </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptrToMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a45bb5f14f010053b22d49b81e127e49c">MemPoolID</a>&#160;</td>
          <td class="paramname"><em>memPoolID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptrToMem</td><td>Pointer to the block of memory to free </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memPoolID</td><td>ID of the memory pool the block of memory was allocated from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the success of the operation </dd></dl>

</div>
</div>
<a class="anchor" id="a4341fd15424f71884ca0838fc43a4488"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_r___r_t_o_s__inc_8h.html#ae652fbd48bfccbcc4f573e8d45529404">RetCode</a> memMngr_MemPoolMalloc </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>ptrToMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a45bb5f14f010053b22d49b81e127e49c">MemPoolID</a>&#160;</td>
          <td class="paramname"><em>memPoolID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate an element from the memory pool specified by the provided MemPoolID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ptrToMem</td><td>Pointer to pointer that will receive the address of the allocated block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memPoolID</td><td>ID of the memory pool to allocate the block of memory from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the success of the operation </dd></dl>

</div>
</div>
<a class="anchor" id="a68b69c7cf2857ba17ceaa63769baa560"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t mergeMemBlck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> **&#160;</td>
          <td class="paramname"><em>blckToMerge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The given memory block is merged with its buddy block if it is free and not cached. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blckToMerge</td><td>Pointer to a pointer to the block to be merged.</td></tr>
  </table>
  </dd>
</dl>
<p>The next and previous free block of memory is calculated. The ptrNXT and ptrPREV of these and the curBlck are adjusted accordingly. The start of the freeMemLst is adjusted if there is no free previous block of memory. </p>

</div>
</div>
<a class="anchor" id="a7215e3278b6a85128484aa16a849b4a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mergeUnevenBlocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const&#160;</td>
          <td class="paramname"><em>added</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The two given memory blocks of unequal size are merged into one memory block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">basis</td><td>Pointer to the block to be merged and used as the pointer to the combined memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">added</td><td>Pointer to the block to be merged with the basis.</td></tr>
  </table>
  </dd>
</dl>
<p>Two blocks of unequal size are merged to make up a new extraordinary sized block. Usually blocks are either split equally or merged with buddies (of the same size so to speak). In order to ease the impact of internal fragmentation, a block can be merged with only parts of its buddy. Flags and sizes of the buddies and the preceding as well as succeeding blocks are adjusted automatically.</p>
<p>Example:</p>
<p>Requested size: 0xC4<br />
 Next bigger block: 0x100<br />
 Next smaller block: 0x80<br />
 Loss: 0x20<br />
</p>
<p>Therefore split bigger block ( to 0x80) and add the remaining need from its ( again split) buddy (0x40). If the size is insufficient the process can be repeated. Again add a split buddy (0x10) to suffice the need best fitting (0xD0)</p>
<p>Requested size: 0xC4<br />
 Next bigger block: 0x100<br />
 Split once: 0x80<br />
 Remainder: 0x44<br />
 Split buddy: 0x40<br />
 Remainder: 0x4<br />
 Split buddy best fit: 0x10<br />
 Combined size: 0xD0<br />
 Loss: 0xC<br />
 SAVED: 0x14<br />
 </p>

</div>
</div>
<a class="anchor" id="af36b050e66e4905bf64029d54ef3bb56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* rCalloc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_r___r_t_o_s__inc_8h.html#aabeb94fe480b56f48c0a3b3e977d3066">MemSize</a>&#160;</td>
          <td class="paramname"><em>desiredSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>DO NOT USE, UNFINISHED </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desiredSize</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad70561f8e55c5019589d8ef867b539b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void reMergeMemBlck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> **&#160;</td>
          <td class="paramname"><em>blckToMerge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The given memory block is merged continuously with its buddy blocks as long as these are neither taken nor cached. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blckToMerge</td><td>Pointer to a pointer to the block to be merged.</td></tr>
  </table>
  </dd>
</dl>
<p>Using mergeMemBlck a Block is merged to its biggest possible size with is free and uncached buddies. </p>

</div>
</div>
<a class="anchor" id="ae12eb126ae45b5e069a7d73871cce534"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rFree </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>pToBeFreed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The provided block of memory will be added to the memory block cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pToBeFreed</td><td>[in] Pointer to the block of memory to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a811bc61478384c58a95488701c4e53f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rFullyFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *&#160;</td>
          <td class="paramname"><em>blckToFullyFree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a block of memory previously allocated with either rMalloc, rCalloc or rRealloc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blckToFullyFree</td><td>[in] Pointer to the block of memory to free and put back onto the free memory blocks list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6d95a879ac03cd989750357490f657a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* rMalloc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_r___r_t_o_s__inc_8h.html#aabeb94fe480b56f48c0a3b3e977d3066">MemSize</a>&#160;</td>
          <td class="paramname"><em>desiredSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a block of memory satisfying the desiredSize property. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desiredSize</td><td>[in] The size of the memory block needed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a21510e924ac77671906169b30c0da628"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* rRealloc </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>ptrToExistingMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_r___r_t_o_s__inc_8h.html#aabeb94fe480b56f48c0a3b3e977d3066">MemSize</a>&#160;</td>
          <td class="paramname"><em>desiredSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a block of memory satisfying the desiredSize property. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrToExistingMem</td><td>[in, out] Pointer to the already allocated memory. </td></tr>
    <tr><td class="paramname">desiredSize</td><td>[in] The size of the memory block needed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a61407be52d8b17c8e4a0a353a23aaa8b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void shrinkCacheFIFO </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the last element out of the cache. </p>
<p>Simply removes the last element of the objCache and sets the new list end accordingly. </p>

</div>
</div>
<a class="anchor" id="a7289114e196270ab93c5dda852b324a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void splitMemBlck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> **const&#160;</td>
          <td class="paramname"><em>blckToSplit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The given memory block is split into two equally sized buddies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blckToSplit</td><td>Pointer to a pointer to the block to be split.</td></tr>
  </table>
  </dd>
</dl>
<p>The given block of memory is split in half. The flags of both blocks are adjusted accordingly. </p>

</div>
</div>
<a class="anchor" id="a2a92216fae1dd09795d592eab2bc28c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void unMergeUnevenBlcks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *const&#160;</td>
          <td class="paramname"><em>blckToUnMerge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The given memory block is split into the unequal buddy blocks it consisted of. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blckToUnMerge</td><td>Pointer to the block to be unmerged.</td></tr>
  </table>
  </dd>
</dl>
<p>A block can be made up of unequally sized buddies. This function extracts these buddies and adds them back to the freeMemLst. Flags and sizes of the buddies and the preceding as well as succeeding blocks are adjusted automatically. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a676c7e6579ccf6d2456accdd6e9aa5f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">buddyOffset = (uint8_t) 0x0u</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Memory address offset of buddy blocks. </p>
<p>In order to be able to XOR the address of a block with its size and get its buddy, addresses have to be altered with an offset beforehand.</p>
<p>E.g.:<br />
 Actual address: 0x1ffff38<br />
 Offset: 0x8<br />
 Possible size: 0x20<br />
 Buddy block = ( (0x1ffff38 - 0x8) ^ 0x20 ) + 0x8</p>
<p>Initialized to 0x0. </p>

</div>
</div>
<a class="anchor" id="aa483a6d5225cf474c6d1a3ad97e0d662"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cacheSize = (uint8_t) 0x0u</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counter for the current size of the objCache. </p>
<p>Keeps track of the elements in the objCache. Decreases and increases automatically when objects are added, removed or kicked out.</p>
<p>Initialized to 0x0. </p>

</div>
</div>
<a class="anchor" id="a1e2c5c4856d56b40b60d0be9741ff390"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">freeMemLst = (<a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *) <a class="el" href="_r___r_t_o_s__inc_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of free blocks of memory. </p>
<p>Contains free blocks of memory that are not cached.</p>
<p>Initialized to NULL. </p>

</div>
</div>
<a class="anchor" id="a020442cc1ea741f7d54df520da4d9cd1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">objCache = (<a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *) <a class="el" href="_r___r_t_o_s__inc_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of free cached blocks of memory. </p>
<p>As soon as a block of memory is freed it is added to the objCache. The size of the obCache is define by CACHE_SIZE. If the size exceeds this limit elements are removed according to FIFO principle.</p>
<p>Initialized to NULL. </p>

</div>
</div>
<a class="anchor" id="a4d4743af777c837eceb4bbe7121e5adc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">objCacheEnd = (<a class="el" href="_r___r_t_o_s__mem_mngr_8h.html#a060a3e62e4e65a36938eb723871b107f">MemMngrHead</a> *) <a class="el" href="_r___r_t_o_s__inc_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End of the objCache List. </p>
<p>The last element in the object cache.</p>
<p>Initialized to NULL. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_74389ed8173ad57b461b9d623a1f3867.html">Source</a></li><li class="navelem"><a class="el" href="_r___r_t_o_s__mem_mngr_8c.html">R_RTOS_memMngr.c</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
