   1              		.cpu cortex-m0plus
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"R_RTOS_sem.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.bss.ar_Sems,"aw",%nobits
  18              		.align	2
  21              	ar_Sems:
  22 0000 00000000 		.space	24
  22      00000000 
  22      00000000 
  22      00000000 
  22      00000000 
  23              		.section	.bss.ar_Mtxs,"aw",%nobits
  24              		.align	2
  27              	ar_Mtxs:
  28 0000 00000000 		.space	16
  28      00000000 
  28      00000000 
  28      00000000 
  29              		.section	.bss.memPoolID_SEM,"aw",%nobits
  32              	memPoolID_SEM:
  33 0000 00       		.space	1
  34              		.section	.bss.memPoolID_MTX,"aw",%nobits
  37              	memPoolID_MTX:
  38 0000 00       		.space	1
  39              		.section	.text.sem_InitSems,"ax",%progbits
  40              		.align	2
  41              		.global	sem_InitSems
  42              		.code	16
  43              		.thumb_func
  45              	sem_InitSems:
  46              	.LFB0:
  47              		.file 1 "../source/R_RTOS/R_RTOS_sem.c"
   1:../source/R_RTOS/R_RTOS_sem.c **** /**
   2:../source/R_RTOS/R_RTOS_sem.c ****  *  \file    R_RTOS_sem.c
   3:../source/R_RTOS/R_RTOS_sem.c ****  *  \author  Christian Neuberger (NeubergerCh50344@th-nuernberg.de)
   4:../source/R_RTOS/R_RTOS_sem.c ****  *  \date    15.12.2015
   5:../source/R_RTOS/R_RTOS_sem.c ****  *
   6:../source/R_RTOS/R_RTOS_sem.c ****  *  \brief Functions for creating, initializing, maintaining Semaphores.
   7:../source/R_RTOS/R_RTOS_sem.c ****  *
   8:../source/R_RTOS/R_RTOS_sem.c ****  *
   9:../source/R_RTOS/R_RTOS_sem.c ****  *  <h2>Priority Inheritance</h2>
  10:../source/R_RTOS/R_RTOS_sem.c ****  *  When access to a specific resource is requested, but cannot be granted, the requesting consumer
  11:../source/R_RTOS/R_RTOS_sem.c ****  *  These wait queues are sorted according to the priority of their entities. Therefore a waiting h
  12:../source/R_RTOS/R_RTOS_sem.c ****  *  access to the resource before a waiting low priority task receives the resource. But if the res
  13:../source/R_RTOS/R_RTOS_sem.c ****  *  task and a high priority task requests access, the resource remains at the lower priority task.
  14:../source/R_RTOS/R_RTOS_sem.c ****  *  is put into a waiting queue and its execution is suspended. If the lower priority task occupyin
  15:../source/R_RTOS/R_RTOS_sem.c ****  *  e.g. a medium priority task is activated, this medium priority task would receive processor tim
  16:../source/R_RTOS/R_RTOS_sem.c ****  *  is currently waiting on the resource. This is called <i>Priority Inversion</i>.<br>
  17:../source/R_RTOS/R_RTOS_sem.c ****  *  To avoid that a lower priority task is executed before a high priority task <i>Priority Inherit
  18:../source/R_RTOS/R_RTOS_sem.c ****  *  priority task is occupying a resource while a high priority task requests access to said resour
  19:../source/R_RTOS/R_RTOS_sem.c ****  *  of the high priority task for the duration of the access to the protected resource. Hence a med
  20:../source/R_RTOS/R_RTOS_sem.c ****  *  lower priority task while it is occupying the resource and the high priority task is waiting fo
  21:../source/R_RTOS/R_RTOS_sem.c ****  *
  22:../source/R_RTOS/R_RTOS_sem.c ****  *
  23:../source/R_RTOS/R_RTOS_sem.c ****  *  <h2>Semaphores</h2>
  24:../source/R_RTOS/R_RTOS_sem.c ****  *  Semaphores are a signaling mechanism to allow multiple access to a protected resource.
  25:../source/R_RTOS/R_RTOS_sem.c ****  *  A consumer does not get ownership of the semaphore. If a consumer is granted access the semapho
  26:../source/R_RTOS/R_RTOS_sem.c ****  *  When the consumer is done with accessing the protected resource the semaphore is then increment
  27:../source/R_RTOS/R_RTOS_sem.c ****  *  As soon as the counter reaches 0 no more accesses to the protected resource will be granted. Al
  28:../source/R_RTOS/R_RTOS_sem.c ****  *  are put into a wait queue and must wait for the counter to increment again and therefore for an
  29:../source/R_RTOS/R_RTOS_sem.c ****  *  was previously granted access to the resource, to release the resource and hence increment the 
  30:../source/R_RTOS/R_RTOS_sem.c ****  *
  31:../source/R_RTOS/R_RTOS_sem.c ****  *  <h3>Counting Semaphores</h3>
  32:../source/R_RTOS/R_RTOS_sem.c ****  *  Counting semaphores contain a counter which can be set to a specific value are incremented vari
  33:../source/R_RTOS/R_RTOS_sem.c ****  *  This is used to limit access to a resource to the counter value.
  34:../source/R_RTOS/R_RTOS_sem.c ****  *
  35:../source/R_RTOS/R_RTOS_sem.c ****  *  <h3>Binary Semaphores</h3>
  36:../source/R_RTOS/R_RTOS_sem.c ****  *  Contrary to counting semaphores, binary semaphores can only take the values 0 or 1 (taken or fr
  37:../source/R_RTOS/R_RTOS_sem.c ****  *  for mutual exclusion, but unlike mutexes the consumer, which is granted access, does not receiv
  38:../source/R_RTOS/R_RTOS_sem.c ****  *
  39:../source/R_RTOS/R_RTOS_sem.c ****  *
  40:../source/R_RTOS/R_RTOS_sem.c ****  *  <h2>Mutexes</h2>
  41:../source/R_RTOS/R_RTOS_sem.c ****  *  Mutexes are a synchronization mechanism for mutual exclusion. As soon as a consumer accesses th
  42:../source/R_RTOS/R_RTOS_sem.c ****  *  protected data, it is granted ownership of the mutex, if the mutex is still available. In case 
  43:../source/R_RTOS/R_RTOS_sem.c ****  *  owned by another consumer, the current consumer is denied access and put into a wait queue unti
  44:../source/R_RTOS/R_RTOS_sem.c ****  *  gives the mutex back to the system. The next consumer in the waiting queue is now granted acces
  45:../source/R_RTOS/R_RTOS_sem.c ****  *  ownership of the mutex.
  46:../source/R_RTOS/R_RTOS_sem.c ****  *
  47:../source/R_RTOS/R_RTOS_sem.c ****  *
  48:../source/R_RTOS/R_RTOS_sem.c ****  *  <h2>Difference Mutex and Binary Semaphore</h2>
  49:../source/R_RTOS/R_RTOS_sem.c ****  *  Since a Binary Semaphore only depends on singaling, it can be signaled from anywhere, whereas a
  50:../source/R_RTOS/R_RTOS_sem.c ****  */
  51:../source/R_RTOS/R_RTOS_sem.c **** 
  52:../source/R_RTOS/R_RTOS_sem.c **** #include "R_RTOS_sem.h"
  53:../source/R_RTOS/R_RTOS_sem.c **** #include "R_RTOS_task.h"
  54:../source/R_RTOS/R_RTOS_sem.c **** 
  55:../source/R_RTOS/R_RTOS_sem.c **** #include "R_RTOS_memMngr.h"
  56:../source/R_RTOS/R_RTOS_sem.c **** 
  57:../source/R_RTOS/R_RTOS_sem.c **** //extern void os_SCHEDULE( void );
  58:../source/R_RTOS/R_RTOS_sem.c **** extern TskTCB tsk_AR[NR_OF_TSKS];
  59:../source/R_RTOS/R_RTOS_sem.c **** 
  60:../source/R_RTOS/R_RTOS_sem.c **** /** \var ar_Sems
  61:../source/R_RTOS/R_RTOS_sem.c ****  *  \brief Contains all semaphores.
  62:../source/R_RTOS/R_RTOS_sem.c ****  */
  63:../source/R_RTOS/R_RTOS_sem.c **** static Sem ar_Sems[AMOUNT_OF_SEMS ];
  64:../source/R_RTOS/R_RTOS_sem.c **** 
  65:../source/R_RTOS/R_RTOS_sem.c **** /** \var ar_Mtxs
  66:../source/R_RTOS/R_RTOS_sem.c ****  *  \brief Contains all mutexes.
  67:../source/R_RTOS/R_RTOS_sem.c ****  */
  68:../source/R_RTOS/R_RTOS_sem.c **** static Mtx ar_Mtxs[AMOUNT_OF_MTXS ];
  69:../source/R_RTOS/R_RTOS_sem.c **** 
  70:../source/R_RTOS/R_RTOS_sem.c **** /** \var memPoolID_SEM
  71:../source/R_RTOS/R_RTOS_sem.c ****  *  \brief ID of the memory pool memory allocation request of semaphores are served from.
  72:../source/R_RTOS/R_RTOS_sem.c ****  */
  73:../source/R_RTOS/R_RTOS_sem.c **** static MemPoolID memPoolID_SEM;
  74:../source/R_RTOS/R_RTOS_sem.c **** 
  75:../source/R_RTOS/R_RTOS_sem.c **** static MemPoolID memPoolID_MTX;
  76:../source/R_RTOS/R_RTOS_sem.c **** 
  77:../source/R_RTOS/R_RTOS_sem.c **** RetCode sem_InitSems( void )
  78:../source/R_RTOS/R_RTOS_sem.c **** {
  48              		.loc 1 78 0
  49              		.cfi_startproc
  50 0000 80B5     		push	{r7, lr}
  51              		.cfi_def_cfa_offset 8
  52              		.cfi_offset 7, -8
  53              		.cfi_offset 14, -4
  54 0002 82B0     		sub	sp, sp, #8
  55              		.cfi_def_cfa_offset 16
  56 0004 00AF     		add	r7, sp, #0
  57              		.cfi_def_cfa_register 7
  79:../source/R_RTOS/R_RTOS_sem.c ****     uint8_t i = (uint8_t) 0x0u;
  58              		.loc 1 79 0
  59 0006 FB1D     		add	r3, r7, #7
  60 0008 0022     		mov	r2, #0
  61 000a 1A70     		strb	r2, [r3]
  80:../source/R_RTOS/R_RTOS_sem.c ****     for ( ; i < AMOUNT_OF_SEMS ; ++i )
  62              		.loc 1 80 0
  63 000c 04E0     		b	.L2
  64              	.L3:
  65              		.loc 1 80 0 is_stmt 0 discriminator 2
  66 000e FB1D     		add	r3, r7, #7
  67 0010 FA1D     		add	r2, r7, #7
  68 0012 1278     		ldrb	r2, [r2]
  69 0014 0132     		add	r2, r2, #1
  70 0016 1A70     		strb	r2, [r3]
  71              	.L2:
  72              		.loc 1 80 0 discriminator 1
  73 0018 FB1D     		add	r3, r7, #7
  74 001a 1B78     		ldrb	r3, [r3]
  75 001c 052B     		cmp	r3, #5
  76 001e F6D9     		bls	.L3
  81:../source/R_RTOS/R_RTOS_sem.c ****     {
  82:../source/R_RTOS/R_RTOS_sem.c ****         //ToDO
  83:../source/R_RTOS/R_RTOS_sem.c **** //        ar_Sems[i].semOccTskID = TSK_ID_NO_TSK;
  84:../source/R_RTOS/R_RTOS_sem.c **** //        ar_Sems[i].semQTskID = TSK_ID_NO_TSK;
  85:../source/R_RTOS/R_RTOS_sem.c **** //        ar_Sems[i].svdPrio = TSK_PRIO_ERROR;
  86:../source/R_RTOS/R_RTOS_sem.c **** //        ar_Sems[i].takenCntr = (SemCntr) 0x0u;
  87:../source/R_RTOS/R_RTOS_sem.c ****     }
  88:../source/R_RTOS/R_RTOS_sem.c ****     memMngr_CreateMemPool( sizeof(SyncEle), MEM_OBJECTS_SEM, &memPoolID_SEM );
  77              		.loc 1 88 0 is_stmt 1
  78 0020 054B     		ldr	r3, .L5
  79 0022 0820     		mov	r0, #8
  80 0024 0421     		mov	r1, #4
  81 0026 1A1C     		mov	r2, r3
  82 0028 FFF7FEFF 		bl	memMngr_CreateMemPool
  89:../source/R_RTOS/R_RTOS_sem.c ****     return RET_OK;
  83              		.loc 1 89 0
  84 002c 0123     		mov	r3, #1
  90:../source/R_RTOS/R_RTOS_sem.c **** }
  85              		.loc 1 90 0
  86 002e 181C     		mov	r0, r3
  87 0030 BD46     		mov	sp, r7
  88 0032 02B0     		add	sp, sp, #8
  89              		@ sp needed
  90 0034 80BD     		pop	{r7, pc}
  91              	.L6:
  92 0036 C046     		.align	2
  93              	.L5:
  94 0038 00000000 		.word	memPoolID_SEM
  95              		.cfi_endproc
  96              	.LFE0:
  98              		.section	.text.mtx_InitMtxs,"ax",%progbits
  99              		.align	2
 100              		.global	mtx_InitMtxs
 101              		.code	16
 102              		.thumb_func
 104              	mtx_InitMtxs:
 105              	.LFB1:
  91:../source/R_RTOS/R_RTOS_sem.c **** 
  92:../source/R_RTOS/R_RTOS_sem.c **** //ToDO
  93:../source/R_RTOS/R_RTOS_sem.c **** RetCode mtx_InitMtxs( void )
  94:../source/R_RTOS/R_RTOS_sem.c **** {
 106              		.loc 1 94 0
 107              		.cfi_startproc
 108 0000 80B5     		push	{r7, lr}
 109              		.cfi_def_cfa_offset 8
 110              		.cfi_offset 7, -8
 111              		.cfi_offset 14, -4
 112 0002 82B0     		sub	sp, sp, #8
 113              		.cfi_def_cfa_offset 16
 114 0004 00AF     		add	r7, sp, #0
 115              		.cfi_def_cfa_register 7
  95:../source/R_RTOS/R_RTOS_sem.c ****     uint8_t i = (uint8_t) 0x0u;
 116              		.loc 1 95 0
 117 0006 FB1D     		add	r3, r7, #7
 118 0008 0022     		mov	r2, #0
 119 000a 1A70     		strb	r2, [r3]
  96:../source/R_RTOS/R_RTOS_sem.c ****     for ( ; i < AMOUNT_OF_MTXS ; ++i )
 120              		.loc 1 96 0
 121 000c 18E0     		b	.L8
 122              	.L9:
  97:../source/R_RTOS/R_RTOS_sem.c ****     {
  98:../source/R_RTOS/R_RTOS_sem.c ****         ar_Mtxs[i].mtxOccTskID = TSK_ID_NO_TSK;
 123              		.loc 1 98 0 discriminator 2
 124 000e FB1D     		add	r3, r7, #7
 125 0010 1B78     		ldrb	r3, [r3]
 126 0012 134A     		ldr	r2, .L11
 127 0014 9B00     		lsl	r3, r3, #2
 128 0016 D318     		add	r3, r2, r3
 129 0018 0022     		mov	r2, #0
 130 001a 5A70     		strb	r2, [r3, #1]
  99:../source/R_RTOS/R_RTOS_sem.c ****         ar_Mtxs[i].mtxQStrtTskID = TSK_ID_NO_TSK;
 131              		.loc 1 99 0 discriminator 2
 132 001c FB1D     		add	r3, r7, #7
 133 001e 1A78     		ldrb	r2, [r3]
 134 0020 0F4B     		ldr	r3, .L11
 135 0022 9200     		lsl	r2, r2, #2
 136 0024 0021     		mov	r1, #0
 137 0026 D154     		strb	r1, [r2, r3]
 100:../source/R_RTOS/R_RTOS_sem.c ****         ar_Mtxs[i].svdTskPrio = TSK_PRIO_ERROR;
 138              		.loc 1 100 0 discriminator 2
 139 0028 FB1D     		add	r3, r7, #7
 140 002a 1B78     		ldrb	r3, [r3]
 141 002c 0C4A     		ldr	r2, .L11
 142 002e 9B00     		lsl	r3, r3, #2
 143 0030 D318     		add	r3, r2, r3
 144 0032 0022     		mov	r2, #0
 145 0034 9A70     		strb	r2, [r3, #2]
  96:../source/R_RTOS/R_RTOS_sem.c ****     for ( ; i < AMOUNT_OF_MTXS ; ++i )
 146              		.loc 1 96 0 discriminator 2
 147 0036 FB1D     		add	r3, r7, #7
 148 0038 FA1D     		add	r2, r7, #7
 149 003a 1278     		ldrb	r2, [r2]
 150 003c 0132     		add	r2, r2, #1
 151 003e 1A70     		strb	r2, [r3]
 152              	.L8:
  96:../source/R_RTOS/R_RTOS_sem.c ****     for ( ; i < AMOUNT_OF_MTXS ; ++i )
 153              		.loc 1 96 0 is_stmt 0 discriminator 1
 154 0040 FB1D     		add	r3, r7, #7
 155 0042 1B78     		ldrb	r3, [r3]
 156 0044 032B     		cmp	r3, #3
 157 0046 E2D9     		bls	.L9
 101:../source/R_RTOS/R_RTOS_sem.c ****     }
 102:../source/R_RTOS/R_RTOS_sem.c ****     memMngr_CreateMemPool( sizeof(SyncEle), MEM_OBJECTS_MTX, &memPoolID_MTX );
 158              		.loc 1 102 0 is_stmt 1
 159 0048 064B     		ldr	r3, .L11+4
 160 004a 0820     		mov	r0, #8
 161 004c 0421     		mov	r1, #4
 162 004e 1A1C     		mov	r2, r3
 163 0050 FFF7FEFF 		bl	memMngr_CreateMemPool
 103:../source/R_RTOS/R_RTOS_sem.c ****     return RET_OK;
 164              		.loc 1 103 0
 165 0054 0123     		mov	r3, #1
 104:../source/R_RTOS/R_RTOS_sem.c **** }
 166              		.loc 1 104 0
 167 0056 181C     		mov	r0, r3
 168 0058 BD46     		mov	sp, r7
 169 005a 02B0     		add	sp, sp, #8
 170              		@ sp needed
 171 005c 80BD     		pop	{r7, pc}
 172              	.L12:
 173 005e C046     		.align	2
 174              	.L11:
 175 0060 00000000 		.word	ar_Mtxs
 176 0064 00000000 		.word	memPoolID_MTX
 177              		.cfi_endproc
 178              	.LFE1:
 180              		.section	.text.mtx_InsertTskMtxQ,"ax",%progbits
 181              		.align	2
 182              		.code	16
 183              		.thumb_func
 185              	mtx_InsertTskMtxQ:
 186              	.LFB2:
 105:../source/R_RTOS/R_RTOS_sem.c **** 
 106:../source/R_RTOS/R_RTOS_sem.c **** static RetCode mtx_InsertTskMtxQ( PMtx pMtx, PTskTCB pTskToIns )
 107:../source/R_RTOS/R_RTOS_sem.c **** {
 187              		.loc 1 107 0
 188              		.cfi_startproc
 189 0000 80B5     		push	{r7, lr}
 190              		.cfi_def_cfa_offset 8
 191              		.cfi_offset 7, -8
 192              		.cfi_offset 14, -4
 193 0002 84B0     		sub	sp, sp, #16
 194              		.cfi_def_cfa_offset 24
 195 0004 00AF     		add	r7, sp, #0
 196              		.cfi_def_cfa_register 7
 197 0006 7860     		str	r0, [r7, #4]
 198 0008 3960     		str	r1, [r7]
 108:../source/R_RTOS/R_RTOS_sem.c ****     //DEBUG
 109:../source/R_RTOS/R_RTOS_sem.c ****     if ( ( (uint32_t) pMtx == ( uint32_t ) NULL ) || ( (uint32_t) pTskToIns
 199              		.loc 1 109 0
 200 000a 7B68     		ldr	r3, [r7, #4]
 201 000c 002B     		cmp	r3, #0
 202 000e 02D0     		beq	.L14
 203              		.loc 1 109 0 is_stmt 0 discriminator 1
 204 0010 3B68     		ldr	r3, [r7]
 205 0012 002B     		cmp	r3, #0
 206 0014 01D1     		bne	.L15
 207              	.L14:
 110:../source/R_RTOS/R_RTOS_sem.c ****             == ( uint32_t ) NULL ) )
 111:../source/R_RTOS/R_RTOS_sem.c ****         return RET_NOK;
 208              		.loc 1 111 0 is_stmt 1
 209 0016 0023     		mov	r3, #0
 210 0018 4BE0     		b	.L16
 211              	.L15:
 112:../source/R_RTOS/R_RTOS_sem.c ****     //\DEBUG
 113:../source/R_RTOS/R_RTOS_sem.c **** 
 114:../source/R_RTOS/R_RTOS_sem.c ****     if ( pMtx->mtxQStrtTskID == TSK_ID_NO_TSK )
 212              		.loc 1 114 0
 213 001a 7B68     		ldr	r3, [r7, #4]
 214 001c 1B78     		ldrb	r3, [r3]
 215 001e 002B     		cmp	r3, #0
 216 0020 0DD1     		bne	.L17
 115:../source/R_RTOS/R_RTOS_sem.c ****     {
 116:../source/R_RTOS/R_RTOS_sem.c ****         // NO QUEUE YET => START A QUEUE
 117:../source/R_RTOS/R_RTOS_sem.c **** 
 118:../source/R_RTOS/R_RTOS_sem.c ****         pMtx->mtxQStrtTskID = pTskToIns->tskID;
 217              		.loc 1 118 0
 218 0022 3A68     		ldr	r2, [r7]
 219 0024 2123     		mov	r3, #33
 220 0026 D25C     		ldrb	r2, [r2, r3]
 221 0028 7B68     		ldr	r3, [r7, #4]
 222 002a 1A70     		strb	r2, [r3]
 119:../source/R_RTOS/R_RTOS_sem.c ****         // given task is the start and end of the new queue
 120:../source/R_RTOS/R_RTOS_sem.c ****         pTskToIns->nxtTsk = TSK_ID_NO_TSK;
 223              		.loc 1 120 0
 224 002c 3A68     		ldr	r2, [r7]
 225 002e 2223     		mov	r3, #34
 226 0030 0021     		mov	r1, #0
 227 0032 D154     		strb	r1, [r2, r3]
 121:../source/R_RTOS/R_RTOS_sem.c ****         pTskToIns->prvTsk = TSK_ID_NO_TSK;
 228              		.loc 1 121 0
 229 0034 3A68     		ldr	r2, [r7]
 230 0036 2323     		mov	r3, #35
 231 0038 0021     		mov	r1, #0
 232 003a D154     		strb	r1, [r2, r3]
 233 003c 38E0     		b	.L18
 234              	.L17:
 235              	.LBB2:
 122:../source/R_RTOS/R_RTOS_sem.c ****     }
 123:../source/R_RTOS/R_RTOS_sem.c ****     else
 124:../source/R_RTOS/R_RTOS_sem.c ****     {
 125:../source/R_RTOS/R_RTOS_sem.c ****         // THERE IS A QUEUE => INSERT ACCORDING TO PRIORITY
 126:../source/R_RTOS/R_RTOS_sem.c ****         PTskTCB curTsk = &tsk_AR[pMtx->mtxQStrtTskID];
 236              		.loc 1 126 0
 237 003e 7B68     		ldr	r3, [r7, #4]
 238 0040 1B78     		ldrb	r3, [r3]
 239 0042 1A1C     		mov	r2, r3
 240 0044 131C     		mov	r3, r2
 241 0046 DB00     		lsl	r3, r3, #3
 242 0048 9B18     		add	r3, r3, r2
 243 004a 9B00     		lsl	r3, r3, #2
 244 004c 1B4A     		ldr	r2, .L23
 245 004e 9B18     		add	r3, r3, r2
 246 0050 FB60     		str	r3, [r7, #12]
 127:../source/R_RTOS/R_RTOS_sem.c ****         while ( curTsk->tskPrio >= pTskToIns->tskPrio )
 247              		.loc 1 127 0
 248 0052 12E0     		b	.L19
 249              	.L22:
 128:../source/R_RTOS/R_RTOS_sem.c ****         {
 129:../source/R_RTOS/R_RTOS_sem.c ****             if ( curTsk->nxtTsk == TSK_ID_NO_TSK )
 250              		.loc 1 129 0
 251 0054 FA68     		ldr	r2, [r7, #12]
 252 0056 2223     		mov	r3, #34
 253 0058 D35C     		ldrb	r3, [r2, r3]
 254 005a DBB2     		uxtb	r3, r3
 255 005c 002B     		cmp	r3, #0
 256 005e 00D1     		bne	.L20
 130:../source/R_RTOS/R_RTOS_sem.c ****             {
 131:../source/R_RTOS/R_RTOS_sem.c ****                 break;
 257              		.loc 1 131 0
 258 0060 13E0     		b	.L21
 259              	.L20:
 132:../source/R_RTOS/R_RTOS_sem.c ****             }
 133:../source/R_RTOS/R_RTOS_sem.c ****             curTsk = &tsk_AR[curTsk->nxtTsk];    // advance in the list
 260              		.loc 1 133 0
 261 0062 FA68     		ldr	r2, [r7, #12]
 262 0064 2223     		mov	r3, #34
 263 0066 D35C     		ldrb	r3, [r2, r3]
 264 0068 DBB2     		uxtb	r3, r3
 265 006a 1A1C     		mov	r2, r3
 266 006c 131C     		mov	r3, r2
 267 006e DB00     		lsl	r3, r3, #3
 268 0070 9B18     		add	r3, r3, r2
 269 0072 9B00     		lsl	r3, r3, #2
 270 0074 114A     		ldr	r2, .L23
 271 0076 9B18     		add	r3, r3, r2
 272 0078 FB60     		str	r3, [r7, #12]
 273              	.L19:
 127:../source/R_RTOS/R_RTOS_sem.c ****         while ( curTsk->tskPrio >= pTskToIns->tskPrio )
 274              		.loc 1 127 0 discriminator 1
 275 007a FB68     		ldr	r3, [r7, #12]
 276 007c DB7F     		ldrb	r3, [r3, #31]
 277 007e DAB2     		uxtb	r2, r3
 278 0080 3B68     		ldr	r3, [r7]
 279 0082 DB7F     		ldrb	r3, [r3, #31]
 280 0084 DBB2     		uxtb	r3, r3
 281 0086 9A42     		cmp	r2, r3
 282 0088 E4D2     		bcs	.L22
 283              	.L21:
 134:../source/R_RTOS/R_RTOS_sem.c ****         }
 135:../source/R_RTOS/R_RTOS_sem.c ****         pTskToIns->prvTsk = curTsk->tskID;    // previous task to new task is the current task
 284              		.loc 1 135 0
 285 008a FA68     		ldr	r2, [r7, #12]
 286 008c 2123     		mov	r3, #33
 287 008e D15C     		ldrb	r1, [r2, r3]
 288 0090 3A68     		ldr	r2, [r7]
 289 0092 2323     		mov	r3, #35
 290 0094 D154     		strb	r1, [r2, r3]
 136:../source/R_RTOS/R_RTOS_sem.c ****         pTskToIns->nxtTsk = curTsk->nxtTsk;    // next task to the new task is the former next task
 291              		.loc 1 136 0
 292 0096 FA68     		ldr	r2, [r7, #12]
 293 0098 2223     		mov	r3, #34
 294 009a D35C     		ldrb	r3, [r2, r3]
 295 009c D9B2     		uxtb	r1, r3
 296 009e 3A68     		ldr	r2, [r7]
 297 00a0 2223     		mov	r3, #34
 298 00a2 D154     		strb	r1, [r2, r3]
 137:../source/R_RTOS/R_RTOS_sem.c ****         curTsk->nxtTsk = pTskToIns->tskID;    // new task is now the next task to the current task
 299              		.loc 1 137 0
 300 00a4 3A68     		ldr	r2, [r7]
 301 00a6 2123     		mov	r3, #33
 302 00a8 D15C     		ldrb	r1, [r2, r3]
 303 00aa FA68     		ldr	r2, [r7, #12]
 304 00ac 2223     		mov	r3, #34
 305 00ae D154     		strb	r1, [r2, r3]
 306              	.L18:
 307              	.LBE2:
 138:../source/R_RTOS/R_RTOS_sem.c ****     }
 139:../source/R_RTOS/R_RTOS_sem.c **** 
 140:../source/R_RTOS/R_RTOS_sem.c ****     return RET_OK;
 308              		.loc 1 140 0
 309 00b0 0123     		mov	r3, #1
 310              	.L16:
 141:../source/R_RTOS/R_RTOS_sem.c **** }
 311              		.loc 1 141 0
 312 00b2 181C     		mov	r0, r3
 313 00b4 BD46     		mov	sp, r7
 314 00b6 04B0     		add	sp, sp, #16
 315              		@ sp needed
 316 00b8 80BD     		pop	{r7, pc}
 317              	.L24:
 318 00ba C046     		.align	2
 319              	.L23:
 320 00bc 00000000 		.word	tsk_AR
 321              		.cfi_endproc
 322              	.LFE2:
 324              		.section	.text.mtx_GetNextTskMtxQ,"ax",%progbits
 325              		.align	2
 326              		.code	16
 327              		.thumb_func
 329              	mtx_GetNextTskMtxQ:
 330              	.LFB3:
 142:../source/R_RTOS/R_RTOS_sem.c **** 
 143:../source/R_RTOS/R_RTOS_sem.c **** static RetCode mtx_GetNextTskMtxQ( PMtx pMtx )
 144:../source/R_RTOS/R_RTOS_sem.c **** {
 331              		.loc 1 144 0
 332              		.cfi_startproc
 333 0000 80B5     		push	{r7, lr}
 334              		.cfi_def_cfa_offset 8
 335              		.cfi_offset 7, -8
 336              		.cfi_offset 14, -4
 337 0002 84B0     		sub	sp, sp, #16
 338              		.cfi_def_cfa_offset 24
 339 0004 00AF     		add	r7, sp, #0
 340              		.cfi_def_cfa_register 7
 341 0006 7860     		str	r0, [r7, #4]
 145:../source/R_RTOS/R_RTOS_sem.c ****     //DEBUG
 146:../source/R_RTOS/R_RTOS_sem.c ****     if ( (uint32_t) pMtx == ( uint32_t ) NULL )
 342              		.loc 1 146 0
 343 0008 7B68     		ldr	r3, [r7, #4]
 344 000a 002B     		cmp	r3, #0
 345 000c 01D1     		bne	.L26
 147:../source/R_RTOS/R_RTOS_sem.c ****     {
 148:../source/R_RTOS/R_RTOS_sem.c ****         // NO START NODE
 149:../source/R_RTOS/R_RTOS_sem.c ****         return RET_NOK;
 346              		.loc 1 149 0
 347 000e 0023     		mov	r3, #0
 348 0010 2FE0     		b	.L27
 349              	.L26:
 150:../source/R_RTOS/R_RTOS_sem.c ****     }
 151:../source/R_RTOS/R_RTOS_sem.c ****     //\DEBUG
 152:../source/R_RTOS/R_RTOS_sem.c **** 
 153:../source/R_RTOS/R_RTOS_sem.c ****     pMtx->mtxOccTskID = pMtx->mtxQStrtTskID;
 350              		.loc 1 153 0
 351 0012 7B68     		ldr	r3, [r7, #4]
 352 0014 1A78     		ldrb	r2, [r3]
 353 0016 7B68     		ldr	r3, [r7, #4]
 354 0018 5A70     		strb	r2, [r3, #1]
 154:../source/R_RTOS/R_RTOS_sem.c **** 
 155:../source/R_RTOS/R_RTOS_sem.c ****     if ( pMtx->mtxQStrtTskID != TSK_ID_NO_TSK )
 355              		.loc 1 155 0
 356 001a 7B68     		ldr	r3, [r7, #4]
 357 001c 1B78     		ldrb	r3, [r3]
 358 001e 002B     		cmp	r3, #0
 359 0020 26D0     		beq	.L28
 360              	.LBB3:
 156:../source/R_RTOS/R_RTOS_sem.c ****     {
 157:../source/R_RTOS/R_RTOS_sem.c ****         PTskTCB nxtTsk = &tsk_AR[pMtx->mtxQStrtTskID];
 361              		.loc 1 157 0
 362 0022 7B68     		ldr	r3, [r7, #4]
 363 0024 1B78     		ldrb	r3, [r3]
 364 0026 1A1C     		mov	r2, r3
 365 0028 131C     		mov	r3, r2
 366 002a DB00     		lsl	r3, r3, #3
 367 002c 9B18     		add	r3, r3, r2
 368 002e 9B00     		lsl	r3, r3, #2
 369 0030 124A     		ldr	r2, .L29
 370 0032 9B18     		add	r3, r3, r2
 371 0034 FB60     		str	r3, [r7, #12]
 158:../source/R_RTOS/R_RTOS_sem.c ****         pMtx->mtxQStrtTskID = nxtTsk->nxtTsk;
 372              		.loc 1 158 0
 373 0036 FA68     		ldr	r2, [r7, #12]
 374 0038 2223     		mov	r3, #34
 375 003a D35C     		ldrb	r3, [r2, r3]
 376 003c DAB2     		uxtb	r2, r3
 377 003e 7B68     		ldr	r3, [r7, #4]
 378 0040 1A70     		strb	r2, [r3]
 159:../source/R_RTOS/R_RTOS_sem.c ****         pMtx->svdTskPrio = nxtTsk->tskPrio;
 379              		.loc 1 159 0
 380 0042 FB68     		ldr	r3, [r7, #12]
 381 0044 DB7F     		ldrb	r3, [r3, #31]
 382 0046 DAB2     		uxtb	r2, r3
 383 0048 7B68     		ldr	r3, [r7, #4]
 384 004a 9A70     		strb	r2, [r3, #2]
 160:../source/R_RTOS/R_RTOS_sem.c ****         tsk_ClrEvt( nxtTsk, nxtTsk->tskSync );
 385              		.loc 1 160 0
 386 004c FB68     		ldr	r3, [r7, #12]
 387 004e 9B69     		ldr	r3, [r3, #24]
 388 0050 FA68     		ldr	r2, [r7, #12]
 389 0052 101C     		mov	r0, r2
 390 0054 191C     		mov	r1, r3
 391 0056 FFF7FEFF 		bl	tsk_ClrEvt
 161:../source/R_RTOS/R_RTOS_sem.c ****         memMngr_MemPoolFree( nxtTsk->tskSync, memPoolID_MTX );    // FREE CURRENT TskSyncEle
 392              		.loc 1 161 0
 393 005a FB68     		ldr	r3, [r7, #12]
 394 005c 9A69     		ldr	r2, [r3, #24]
 395 005e 084B     		ldr	r3, .L29+4
 396 0060 1B78     		ldrb	r3, [r3]
 397 0062 101C     		mov	r0, r2
 398 0064 191C     		mov	r1, r3
 399 0066 FFF7FEFF 		bl	memMngr_MemPoolFree
 162:../source/R_RTOS/R_RTOS_sem.c ****         nxtTsk->tskSync = (PSyncEle) NULL;
 400              		.loc 1 162 0
 401 006a FB68     		ldr	r3, [r7, #12]
 402 006c 0022     		mov	r2, #0
 403 006e 9A61     		str	r2, [r3, #24]
 404              	.L28:
 405              	.LBE3:
 163:../source/R_RTOS/R_RTOS_sem.c ****     }
 164:../source/R_RTOS/R_RTOS_sem.c **** 
 165:../source/R_RTOS/R_RTOS_sem.c ****     return RET_OK;
 406              		.loc 1 165 0
 407 0070 0123     		mov	r3, #1
 408              	.L27:
 166:../source/R_RTOS/R_RTOS_sem.c **** }
 409              		.loc 1 166 0
 410 0072 181C     		mov	r0, r3
 411 0074 BD46     		mov	sp, r7
 412 0076 04B0     		add	sp, sp, #16
 413              		@ sp needed
 414 0078 80BD     		pop	{r7, pc}
 415              	.L30:
 416 007a C046     		.align	2
 417              	.L29:
 418 007c 00000000 		.word	tsk_AR
 419 0080 00000000 		.word	memPoolID_MTX
 420              		.cfi_endproc
 421              	.LFE3:
 423              		.section	.text.mtx_TakeMtx,"ax",%progbits
 424              		.align	2
 425              		.global	mtx_TakeMtx
 426              		.code	16
 427              		.thumb_func
 429              	mtx_TakeMtx:
 430              	.LFB4:
 167:../source/R_RTOS/R_RTOS_sem.c **** 
 168:../source/R_RTOS/R_RTOS_sem.c **** RetCode mtx_TakeMtx(
 169:../source/R_RTOS/R_RTOS_sem.c ****                      PTskTCB const tsk,
 170:../source/R_RTOS/R_RTOS_sem.c ****                      const MtxNr mtxNr,
 171:../source/R_RTOS/R_RTOS_sem.c ****                      const SysTicks maxSysTicksToWait )
 172:../source/R_RTOS/R_RTOS_sem.c **** {
 431              		.loc 1 172 0
 432              		.cfi_startproc
 433 0000 80B5     		push	{r7, lr}
 434              		.cfi_def_cfa_offset 8
 435              		.cfi_offset 7, -8
 436              		.cfi_offset 14, -4
 437 0002 86B0     		sub	sp, sp, #24
 438              		.cfi_def_cfa_offset 32
 439 0004 00AF     		add	r7, sp, #0
 440              		.cfi_def_cfa_register 7
 441 0006 7860     		str	r0, [r7, #4]
 442 0008 FB1C     		add	r3, r7, #3
 443 000a 1970     		strb	r1, [r3]
 444 000c BB1C     		add	r3, r7, #2
 445 000e 1A70     		strb	r2, [r3]
 173:../source/R_RTOS/R_RTOS_sem.c ****     //DEBUG
 174:../source/R_RTOS/R_RTOS_sem.c ****     if ( mtxNr >= AMOUNT_OF_MTXS )
 446              		.loc 1 174 0
 447 0010 FB1C     		add	r3, r7, #3
 448 0012 1B78     		ldrb	r3, [r3]
 449 0014 032B     		cmp	r3, #3
 450 0016 01D9     		bls	.L32
 175:../source/R_RTOS/R_RTOS_sem.c ****         return RET_NOK;
 451              		.loc 1 175 0
 452 0018 0023     		mov	r3, #0
 453 001a 61E0     		b	.L33
 454              	.L32:
 176:../source/R_RTOS/R_RTOS_sem.c ****     //\DEBUG
 177:../source/R_RTOS/R_RTOS_sem.c **** 
 178:../source/R_RTOS/R_RTOS_sem.c ****     PMtx pMtx = &ar_Mtxs[mtxNr];
 455              		.loc 1 178 0
 456 001c FB1C     		add	r3, r7, #3
 457 001e 1B78     		ldrb	r3, [r3]
 458 0020 9A00     		lsl	r2, r3, #2
 459 0022 314B     		ldr	r3, .L39
 460 0024 D318     		add	r3, r2, r3
 461 0026 7B61     		str	r3, [r7, #20]
 179:../source/R_RTOS/R_RTOS_sem.c **** 
 180:../source/R_RTOS/R_RTOS_sem.c ****     // The mutex is free, when there is no occupying task
 181:../source/R_RTOS/R_RTOS_sem.c ****     if ( pMtx->mtxOccTskID != TSK_ID_NO_TSK )
 462              		.loc 1 181 0
 463 0028 7B69     		ldr	r3, [r7, #20]
 464 002a 5B78     		ldrb	r3, [r3, #1]
 465 002c 002B     		cmp	r3, #0
 466 002e 49D0     		beq	.L34
 467              	.LBB4:
 182:../source/R_RTOS/R_RTOS_sem.c ****     {
 183:../source/R_RTOS/R_RTOS_sem.c ****         // CHECK IF THE SPECIFIED TASK IS NOT ALREADY WAITING FOR ANY SYNC ELEMENT, WHICH IS AN ERR
 184:../source/R_RTOS/R_RTOS_sem.c ****         //DEBUG
 185:../source/R_RTOS/R_RTOS_sem.c ****         if ( (uint32_t) tsk->tskSync != ( uint32_t ) NULL )
 468              		.loc 1 185 0
 469 0030 7B68     		ldr	r3, [r7, #4]
 470 0032 9B69     		ldr	r3, [r3, #24]
 471 0034 002B     		cmp	r3, #0
 472 0036 01D0     		beq	.L35
 186:../source/R_RTOS/R_RTOS_sem.c ****             return RET_NOK;
 473              		.loc 1 186 0
 474 0038 0023     		mov	r3, #0
 475 003a 51E0     		b	.L33
 476              	.L35:
 187:../source/R_RTOS/R_RTOS_sem.c ****         //\DEBUG
 188:../source/R_RTOS/R_RTOS_sem.c **** 
 189:../source/R_RTOS/R_RTOS_sem.c ****         PSyncEle mtxSync;
 190:../source/R_RTOS/R_RTOS_sem.c ****         memMngr_MemPoolMalloc( &mtxSync, memPoolID_MTX );
 477              		.loc 1 190 0
 478 003c 2B4B     		ldr	r3, .L39+4
 479 003e 1B78     		ldrb	r3, [r3]
 480 0040 3A1C     		mov	r2, r7
 481 0042 0C32     		add	r2, r2, #12
 482 0044 101C     		mov	r0, r2
 483 0046 191C     		mov	r1, r3
 484 0048 FFF7FEFF 		bl	memMngr_MemPoolMalloc
 191:../source/R_RTOS/R_RTOS_sem.c ****         if ( (uint32_t) mtxSync == ( uint32_t ) NULL )
 485              		.loc 1 191 0
 486 004c FB68     		ldr	r3, [r7, #12]
 487 004e 002B     		cmp	r3, #0
 488 0050 05D1     		bne	.L37
 192:../source/R_RTOS/R_RTOS_sem.c ****         {
 193:../source/R_RTOS/R_RTOS_sem.c ****             tsk->tskState = TSK_STATE_ERROR;
 489              		.loc 1 193 0
 490 0052 7A68     		ldr	r2, [r7, #4]
 491 0054 2023     		mov	r3, #32
 492 0056 0021     		mov	r1, #0
 493 0058 D154     		strb	r1, [r2, r3]
 194:../source/R_RTOS/R_RTOS_sem.c ****             return RET_NOK;
 494              		.loc 1 194 0
 495 005a 0023     		mov	r3, #0
 496 005c 40E0     		b	.L33
 497              	.L37:
 195:../source/R_RTOS/R_RTOS_sem.c ****         }
 196:../source/R_RTOS/R_RTOS_sem.c ****         //ToDO
 197:../source/R_RTOS/R_RTOS_sem.c ****         //semSync->maxBlckTime = maxSysTicksToWait;
 198:../source/R_RTOS/R_RTOS_sem.c ****         mtxSync->syncEleID = mtxNr;
 498              		.loc 1 198 0
 499 005e FB68     		ldr	r3, [r7, #12]
 500 0060 FA1C     		add	r2, r7, #3
 501 0062 1278     		ldrb	r2, [r2]
 502 0064 5A70     		strb	r2, [r3, #1]
 199:../source/R_RTOS/R_RTOS_sem.c ****         mtxSync->syncEleType = SyncEle_TYPE_MTX;
 503              		.loc 1 199 0
 504 0066 FB68     		ldr	r3, [r7, #12]
 505 0068 0522     		mov	r2, #5
 506 006a 1A70     		strb	r2, [r3]
 200:../source/R_RTOS/R_RTOS_sem.c ****         //semSync->SyncEleHandle.SemSyncEle.dummy1
 201:../source/R_RTOS/R_RTOS_sem.c ****         tsk->tskSync = mtxSync;
 507              		.loc 1 201 0
 508 006c FA68     		ldr	r2, [r7, #12]
 509 006e 7B68     		ldr	r3, [r7, #4]
 510 0070 9A61     		str	r2, [r3, #24]
 202:../source/R_RTOS/R_RTOS_sem.c ****         tsk_SetEvt( tsk, mtxSync );
 511              		.loc 1 202 0
 512 0072 FB68     		ldr	r3, [r7, #12]
 513 0074 7A68     		ldr	r2, [r7, #4]
 514 0076 101C     		mov	r0, r2
 515 0078 191C     		mov	r1, r3
 516 007a FFF7FEFF 		bl	tsk_SetEvt
 203:../source/R_RTOS/R_RTOS_sem.c **** 
 204:../source/R_RTOS/R_RTOS_sem.c ****         PTskTCB occTsk = &( tsk_AR[pMtx->mtxOccTskID] );
 517              		.loc 1 204 0
 518 007e 7B69     		ldr	r3, [r7, #20]
 519 0080 5B78     		ldrb	r3, [r3, #1]
 520 0082 1A1C     		mov	r2, r3
 521 0084 131C     		mov	r3, r2
 522 0086 DB00     		lsl	r3, r3, #3
 523 0088 9B18     		add	r3, r3, r2
 524 008a 9B00     		lsl	r3, r3, #2
 525 008c 184A     		ldr	r2, .L39+8
 526 008e 9B18     		add	r3, r3, r2
 527 0090 3B61     		str	r3, [r7, #16]
 205:../source/R_RTOS/R_RTOS_sem.c ****         if ( occTsk->tskPrio < tsk->tskPrio )
 528              		.loc 1 205 0
 529 0092 3B69     		ldr	r3, [r7, #16]
 530 0094 DB7F     		ldrb	r3, [r3, #31]
 531 0096 DAB2     		uxtb	r2, r3
 532 0098 7B68     		ldr	r3, [r7, #4]
 533 009a DB7F     		ldrb	r3, [r3, #31]
 534 009c DBB2     		uxtb	r3, r3
 535 009e 9A42     		cmp	r2, r3
 536 00a0 07D2     		bcs	.L38
 206:../source/R_RTOS/R_RTOS_sem.c ****         {
 207:../source/R_RTOS/R_RTOS_sem.c ****             // INHERIT MAXIMUM PRIORITY OF ALL INCOMING TASKS
 208:../source/R_RTOS/R_RTOS_sem.c ****             tsk_ChngePrio( occTsk, tsk->tskPrio );
 537              		.loc 1 208 0
 538 00a2 7B68     		ldr	r3, [r7, #4]
 539 00a4 DB7F     		ldrb	r3, [r3, #31]
 540 00a6 DBB2     		uxtb	r3, r3
 541 00a8 3A69     		ldr	r2, [r7, #16]
 542 00aa 101C     		mov	r0, r2
 543 00ac 191C     		mov	r1, r3
 544 00ae FFF7FEFF 		bl	tsk_ChngePrio
 545              	.L38:
 209:../source/R_RTOS/R_RTOS_sem.c ****         }
 210:../source/R_RTOS/R_RTOS_sem.c ****         return sem_InsertTskSemQ( pMtx, tsk );    // insert the new semaphore according to its task
 546              		.loc 1 210 0
 547 00b2 7A69     		ldr	r2, [r7, #20]
 548 00b4 7B68     		ldr	r3, [r7, #4]
 549 00b6 101C     		mov	r0, r2
 550 00b8 191C     		mov	r1, r3
 551 00ba FFF7FEFF 		bl	sem_InsertTskSemQ
 552 00be 031C     		mov	r3, r0
 553 00c0 DBB2     		uxtb	r3, r3
 554 00c2 0DE0     		b	.L33
 555              	.L34:
 556              	.LBE4:
 211:../source/R_RTOS/R_RTOS_sem.c ****     }
 212:../source/R_RTOS/R_RTOS_sem.c ****     else
 213:../source/R_RTOS/R_RTOS_sem.c ****     {
 214:../source/R_RTOS/R_RTOS_sem.c ****         pMtx->mtxOccTskID = tsk->tskID; // current task is now the occupying task
 557              		.loc 1 214 0
 558 00c4 7A68     		ldr	r2, [r7, #4]
 559 00c6 2123     		mov	r3, #33
 560 00c8 D25C     		ldrb	r2, [r2, r3]
 561 00ca 7B69     		ldr	r3, [r7, #20]
 562 00cc 5A70     		strb	r2, [r3, #1]
 215:../source/R_RTOS/R_RTOS_sem.c ****         pMtx->svdTskPrio = tsk->tskPrio; // save the task priority for the priority inversion proto
 563              		.loc 1 215 0
 564 00ce 7B68     		ldr	r3, [r7, #4]
 565 00d0 DB7F     		ldrb	r3, [r3, #31]
 566 00d2 DAB2     		uxtb	r2, r3
 567 00d4 7B69     		ldr	r3, [r7, #20]
 568 00d6 9A70     		strb	r2, [r3, #2]
 216:../source/R_RTOS/R_RTOS_sem.c ****         // If the semaphore is free, there is also no waiting queue; to make sure, set the Q start 
 217:../source/R_RTOS/R_RTOS_sem.c ****         pMtx->mtxQStrtTskID = TSK_ID_NO_TSK;
 569              		.loc 1 217 0
 570 00d8 7B69     		ldr	r3, [r7, #20]
 571 00da 0022     		mov	r2, #0
 572 00dc 1A70     		strb	r2, [r3]
 218:../source/R_RTOS/R_RTOS_sem.c ****         return RET_OK;
 573              		.loc 1 218 0
 574 00de 0123     		mov	r3, #1
 575              	.L33:
 219:../source/R_RTOS/R_RTOS_sem.c ****     }
 220:../source/R_RTOS/R_RTOS_sem.c **** }
 576              		.loc 1 220 0
 577 00e0 181C     		mov	r0, r3
 578 00e2 BD46     		mov	sp, r7
 579 00e4 06B0     		add	sp, sp, #24
 580              		@ sp needed
 581 00e6 80BD     		pop	{r7, pc}
 582              	.L40:
 583              		.align	2
 584              	.L39:
 585 00e8 00000000 		.word	ar_Mtxs
 586 00ec 00000000 		.word	memPoolID_MTX
 587 00f0 00000000 		.word	tsk_AR
 588              		.cfi_endproc
 589              	.LFE4:
 591              		.section	.text.mtx_GiveMtx,"ax",%progbits
 592              		.align	2
 593              		.global	mtx_GiveMtx
 594              		.code	16
 595              		.thumb_func
 597              	mtx_GiveMtx:
 598              	.LFB5:
 221:../source/R_RTOS/R_RTOS_sem.c **** 
 222:../source/R_RTOS/R_RTOS_sem.c **** RetCode mtx_GiveMtx( PTskTCB const tsk, const MtxNr mtxNr )
 223:../source/R_RTOS/R_RTOS_sem.c **** {
 599              		.loc 1 223 0
 600              		.cfi_startproc
 601 0000 80B5     		push	{r7, lr}
 602              		.cfi_def_cfa_offset 8
 603              		.cfi_offset 7, -8
 604              		.cfi_offset 14, -4
 605 0002 84B0     		sub	sp, sp, #16
 606              		.cfi_def_cfa_offset 24
 607 0004 00AF     		add	r7, sp, #0
 608              		.cfi_def_cfa_register 7
 609 0006 7860     		str	r0, [r7, #4]
 610 0008 0A1C     		mov	r2, r1
 611 000a FB1C     		add	r3, r7, #3
 612 000c 1A70     		strb	r2, [r3]
 224:../source/R_RTOS/R_RTOS_sem.c ****     //DEBUG
 225:../source/R_RTOS/R_RTOS_sem.c ****     if ( mtxNr >= AMOUNT_OF_MTXS )
 613              		.loc 1 225 0
 614 000e FB1C     		add	r3, r7, #3
 615 0010 1B78     		ldrb	r3, [r3]
 616 0012 032B     		cmp	r3, #3
 617 0014 01D9     		bls	.L42
 226:../source/R_RTOS/R_RTOS_sem.c ****         return RET_NOK;
 618              		.loc 1 226 0
 619 0016 0023     		mov	r3, #0
 620 0018 21E0     		b	.L43
 621              	.L42:
 227:../source/R_RTOS/R_RTOS_sem.c ****     //\DEBUG
 228:../source/R_RTOS/R_RTOS_sem.c **** 
 229:../source/R_RTOS/R_RTOS_sem.c ****     PMtx pMtx = &( ar_Mtxs[mtxNr] );
 622              		.loc 1 229 0
 623 001a FB1C     		add	r3, r7, #3
 624 001c 1B78     		ldrb	r3, [r3]
 625 001e 9A00     		lsl	r2, r3, #2
 626 0020 114B     		ldr	r3, .L46
 627 0022 D318     		add	r3, r2, r3
 628 0024 FB60     		str	r3, [r7, #12]
 230:../source/R_RTOS/R_RTOS_sem.c **** 
 231:../source/R_RTOS/R_RTOS_sem.c ****     if ( pMtx->mtxOccTskID != tsk->tskID )    // ONLY THE OCCUPYING TASK CAN GIVE THE MUTEX
 629              		.loc 1 231 0
 630 0026 FB68     		ldr	r3, [r7, #12]
 631 0028 5A78     		ldrb	r2, [r3, #1]
 632 002a 7968     		ldr	r1, [r7, #4]
 633 002c 2123     		mov	r3, #33
 634 002e CB5C     		ldrb	r3, [r1, r3]
 635 0030 9A42     		cmp	r2, r3
 636 0032 01D0     		beq	.L44
 232:../source/R_RTOS/R_RTOS_sem.c ****         return RET_NOK;
 637              		.loc 1 232 0
 638 0034 0023     		mov	r3, #0
 639 0036 12E0     		b	.L43
 640              	.L44:
 233:../source/R_RTOS/R_RTOS_sem.c **** 
 234:../source/R_RTOS/R_RTOS_sem.c ****     if ( tsk->tskPrio != pMtx->svdTskPrio )
 641              		.loc 1 234 0
 642 0038 7B68     		ldr	r3, [r7, #4]
 643 003a DB7F     		ldrb	r3, [r3, #31]
 644 003c DAB2     		uxtb	r2, r3
 645 003e FB68     		ldr	r3, [r7, #12]
 646 0040 9B78     		ldrb	r3, [r3, #2]
 647 0042 9A42     		cmp	r2, r3
 648 0044 06D0     		beq	.L45
 235:../source/R_RTOS/R_RTOS_sem.c ****     {
 236:../source/R_RTOS/R_RTOS_sem.c ****         tsk_ChngePrio( tsk, pMtx->svdTskPrio );
 649              		.loc 1 236 0
 650 0046 FB68     		ldr	r3, [r7, #12]
 651 0048 9B78     		ldrb	r3, [r3, #2]
 652 004a 7A68     		ldr	r2, [r7, #4]
 653 004c 101C     		mov	r0, r2
 654 004e 191C     		mov	r1, r3
 655 0050 FFF7FEFF 		bl	tsk_ChngePrio
 656              	.L45:
 237:../source/R_RTOS/R_RTOS_sem.c ****     }
 238:../source/R_RTOS/R_RTOS_sem.c **** 
 239:../source/R_RTOS/R_RTOS_sem.c ****     return mtx_GetNextTskMtxQ( pMtx );
 657              		.loc 1 239 0
 658 0054 FB68     		ldr	r3, [r7, #12]
 659 0056 181C     		mov	r0, r3
 660 0058 FFF7FEFF 		bl	mtx_GetNextTskMtxQ
 661 005c 031C     		mov	r3, r0
 662              	.L43:
 240:../source/R_RTOS/R_RTOS_sem.c **** }
 663              		.loc 1 240 0
 664 005e 181C     		mov	r0, r3
 665 0060 BD46     		mov	sp, r7
 666 0062 04B0     		add	sp, sp, #16
 667              		@ sp needed
 668 0064 80BD     		pop	{r7, pc}
 669              	.L47:
 670 0066 C046     		.align	2
 671              	.L46:
 672 0068 00000000 		.word	ar_Mtxs
 673              		.cfi_endproc
 674              	.LFE5:
 676              		.section	.text.sem_GiveUpOnSem,"ax",%progbits
 677              		.align	2
 678              		.global	sem_GiveUpOnSem
 679              		.code	16
 680              		.thumb_func
 682              	sem_GiveUpOnSem:
 683              	.LFB6:
 241:../source/R_RTOS/R_RTOS_sem.c **** 
 242:../source/R_RTOS/R_RTOS_sem.c **** RetCode sem_GiveUpOnSem( PTskTCB const tsk )
 243:../source/R_RTOS/R_RTOS_sem.c **** {
 684              		.loc 1 243 0
 685              		.cfi_startproc
 686 0000 80B5     		push	{r7, lr}
 687              		.cfi_def_cfa_offset 8
 688              		.cfi_offset 7, -8
 689              		.cfi_offset 14, -4
 690 0002 82B0     		sub	sp, sp, #8
 691              		.cfi_def_cfa_offset 16
 692 0004 00AF     		add	r7, sp, #0
 693              		.cfi_def_cfa_register 7
 694 0006 7860     		str	r0, [r7, #4]
 244:../source/R_RTOS/R_RTOS_sem.c ****     //ToDO
 245:../source/R_RTOS/R_RTOS_sem.c **** 
 246:../source/R_RTOS/R_RTOS_sem.c **** //    PSem sem;
 247:../source/R_RTOS/R_RTOS_sem.c **** //    uint8_t semArCnt = (uint8_t) 0x0u;
 248:../source/R_RTOS/R_RTOS_sem.c **** //
 249:../source/R_RTOS/R_RTOS_sem.c **** //    for ( ; semArCnt < AMOUNT_OF_SEMS ; semArCnt++ )
 250:../source/R_RTOS/R_RTOS_sem.c **** //    {
 251:../source/R_RTOS/R_RTOS_sem.c **** //        sem = &ar_Sems[semArCnt];
 252:../source/R_RTOS/R_RTOS_sem.c **** //        // If the semaphore is taken and the given task is the start of the list, release the sem
 253:../source/R_RTOS/R_RTOS_sem.c **** //        if ( sem->takenCntr )    //ToDo is this really needed? semOccTskID should be TSK_ID_NO_TS
 254:../source/R_RTOS/R_RTOS_sem.c **** //        {
 255:../source/R_RTOS/R_RTOS_sem.c **** //            if ( sem->semOccTskID == tsk->tskID )
 256:../source/R_RTOS/R_RTOS_sem.c **** //            {
 257:../source/R_RTOS/R_RTOS_sem.c **** //                // Get the next task from the semaphore queue -> will be stored as the new start 
 258:../source/R_RTOS/R_RTOS_sem.c **** //                sem_GetNextTskSemQ( sem );    //ToDo RetCode??
 259:../source/R_RTOS/R_RTOS_sem.c **** //            }
 260:../source/R_RTOS/R_RTOS_sem.c **** //        }
 261:../source/R_RTOS/R_RTOS_sem.c **** //    }
 262:../source/R_RTOS/R_RTOS_sem.c ****     return RET_OK;
 695              		.loc 1 262 0
 696 0008 0123     		mov	r3, #1
 263:../source/R_RTOS/R_RTOS_sem.c **** }
 697              		.loc 1 263 0
 698 000a 181C     		mov	r0, r3
 699 000c BD46     		mov	sp, r7
 700 000e 02B0     		add	sp, sp, #8
 701              		@ sp needed
 702 0010 80BD     		pop	{r7, pc}
 703              		.cfi_endproc
 704              	.LFE6:
 706 0012 C046     		.section	.text.sem_DeleteTskSemQ,"ax",%progbits
 707              		.align	2
 708              		.global	sem_DeleteTskSemQ
 709              		.code	16
 710              		.thumb_func
 712              	sem_DeleteTskSemQ:
 713              	.LFB7:
 264:../source/R_RTOS/R_RTOS_sem.c **** 
 265:../source/R_RTOS/R_RTOS_sem.c **** // WARNING! MAKE SURE THAT THE TASK !IS! IN THE SEMAPHORE WAITING TASK QUEUE!!!
 266:../source/R_RTOS/R_RTOS_sem.c **** RetCode sem_DeleteTskSemQ( PTskTCB const tsk )
 267:../source/R_RTOS/R_RTOS_sem.c **** {
 714              		.loc 1 267 0
 715              		.cfi_startproc
 716 0000 80B5     		push	{r7, lr}
 717              		.cfi_def_cfa_offset 8
 718              		.cfi_offset 7, -8
 719              		.cfi_offset 14, -4
 720 0002 82B0     		sub	sp, sp, #8
 721              		.cfi_def_cfa_offset 16
 722 0004 00AF     		add	r7, sp, #0
 723              		.cfi_def_cfa_register 7
 724 0006 7860     		str	r0, [r7, #4]
 268:../source/R_RTOS/R_RTOS_sem.c ****     //ToDO !!!
 269:../source/R_RTOS/R_RTOS_sem.c **** //    if ( ( (uint32_t) tsk->tskSync == ( uint32_t ) NULL ) || ( tsk->tskSync->syncEleType
 270:../source/R_RTOS/R_RTOS_sem.c **** //            != SyncEle_TYPE_SEM ) )
 271:../source/R_RTOS/R_RTOS_sem.c **** //        return RET_NOK;    // WTF?
 272:../source/R_RTOS/R_RTOS_sem.c **** //
 273:../source/R_RTOS/R_RTOS_sem.c **** //    PSem sem = &ar_Sems[tsk->tskSync->syncEleID];
 274:../source/R_RTOS/R_RTOS_sem.c **** //
 275:../source/R_RTOS/R_RTOS_sem.c **** //    if ( sem->semQTskID == tsk->tskID )
 276:../source/R_RTOS/R_RTOS_sem.c **** //    {
 277:../source/R_RTOS/R_RTOS_sem.c **** //        sem->semQTskID = tsk->nxtTsk;
 278:../source/R_RTOS/R_RTOS_sem.c **** //        if ( tsk->nxtTsk != TSK_ID_NO_TSK )
 279:../source/R_RTOS/R_RTOS_sem.c **** //        {
 280:../source/R_RTOS/R_RTOS_sem.c **** //            tsk_AR[tsk->nxtTsk].prvTsk = TSK_ID_NO_TSK;
 281:../source/R_RTOS/R_RTOS_sem.c **** //        }
 282:../source/R_RTOS/R_RTOS_sem.c **** //    }
 283:../source/R_RTOS/R_RTOS_sem.c **** //    else
 284:../source/R_RTOS/R_RTOS_sem.c **** //    {
 285:../source/R_RTOS/R_RTOS_sem.c **** //        if ( tsk->nxtTsk != TSK_ID_NO_TSK )
 286:../source/R_RTOS/R_RTOS_sem.c **** //        {
 287:../source/R_RTOS/R_RTOS_sem.c **** //            tsk_AR[tsk->nxtTsk].prvTsk = tsk->prvTsk;
 288:../source/R_RTOS/R_RTOS_sem.c **** //        }
 289:../source/R_RTOS/R_RTOS_sem.c **** //        if ( tsk->prvTsk != TSK_ID_NO_TSK )
 290:../source/R_RTOS/R_RTOS_sem.c **** //        {
 291:../source/R_RTOS/R_RTOS_sem.c **** //            tsk_AR[tsk->prvTsk].nxtTsk = tsk->nxtTsk;
 292:../source/R_RTOS/R_RTOS_sem.c **** //        }
 293:../source/R_RTOS/R_RTOS_sem.c **** //    }
 294:../source/R_RTOS/R_RTOS_sem.c **** //
 295:../source/R_RTOS/R_RTOS_sem.c **** //    memMngr_MemPoolFree( tsk->tskSync, memPoolID_SEM );    // FREE CURRENT NODE
 296:../source/R_RTOS/R_RTOS_sem.c **** 
 297:../source/R_RTOS/R_RTOS_sem.c ****     return RET_OK;
 725              		.loc 1 297 0
 726 0008 0123     		mov	r3, #1
 298:../source/R_RTOS/R_RTOS_sem.c **** }
 727              		.loc 1 298 0
 728 000a 181C     		mov	r0, r3
 729 000c BD46     		mov	sp, r7
 730 000e 02B0     		add	sp, sp, #8
 731              		@ sp needed
 732 0010 80BD     		pop	{r7, pc}
 733              		.cfi_endproc
 734              	.LFE7:
 736 0012 C046     		.text
 737              	.Letext0:
 738              		.file 2 "c:\\freescale\\kds_3.0.0\\toolchain\\arm-none-eabi\\include\\machine\\_default_types.h"
 739              		.file 3 "c:\\freescale\\kds_3.0.0\\toolchain\\arm-none-eabi\\include\\stdint.h"
 740              		.file 4 "../include/R_RTOS_inc.h"
 741              		.file 5 "../include/R_RTOS_memMngr.h"
DEFINED SYMBOLS
                            *ABS*:00000000 R_RTOS_sem.c
        R_RTOS_sem.s:18     .bss.ar_Sems:00000000 $d
        R_RTOS_sem.s:21     .bss.ar_Sems:00000000 ar_Sems
        R_RTOS_sem.s:24     .bss.ar_Mtxs:00000000 $d
        R_RTOS_sem.s:27     .bss.ar_Mtxs:00000000 ar_Mtxs
        R_RTOS_sem.s:32     .bss.memPoolID_SEM:00000000 memPoolID_SEM
        R_RTOS_sem.s:33     .bss.memPoolID_SEM:00000000 $d
        R_RTOS_sem.s:37     .bss.memPoolID_MTX:00000000 memPoolID_MTX
        R_RTOS_sem.s:38     .bss.memPoolID_MTX:00000000 $d
        R_RTOS_sem.s:40     .text.sem_InitSems:00000000 $t
        R_RTOS_sem.s:45     .text.sem_InitSems:00000000 sem_InitSems
        R_RTOS_sem.s:94     .text.sem_InitSems:00000038 $d
        R_RTOS_sem.s:99     .text.mtx_InitMtxs:00000000 $t
        R_RTOS_sem.s:104    .text.mtx_InitMtxs:00000000 mtx_InitMtxs
        R_RTOS_sem.s:175    .text.mtx_InitMtxs:00000060 $d
        R_RTOS_sem.s:181    .text.mtx_InsertTskMtxQ:00000000 $t
        R_RTOS_sem.s:185    .text.mtx_InsertTskMtxQ:00000000 mtx_InsertTskMtxQ
        R_RTOS_sem.s:320    .text.mtx_InsertTskMtxQ:000000bc $d
        R_RTOS_sem.s:325    .text.mtx_GetNextTskMtxQ:00000000 $t
        R_RTOS_sem.s:329    .text.mtx_GetNextTskMtxQ:00000000 mtx_GetNextTskMtxQ
        R_RTOS_sem.s:418    .text.mtx_GetNextTskMtxQ:0000007c $d
        R_RTOS_sem.s:424    .text.mtx_TakeMtx:00000000 $t
        R_RTOS_sem.s:429    .text.mtx_TakeMtx:00000000 mtx_TakeMtx
        R_RTOS_sem.s:585    .text.mtx_TakeMtx:000000e8 $d
        R_RTOS_sem.s:592    .text.mtx_GiveMtx:00000000 $t
        R_RTOS_sem.s:597    .text.mtx_GiveMtx:00000000 mtx_GiveMtx
        R_RTOS_sem.s:672    .text.mtx_GiveMtx:00000068 $d
        R_RTOS_sem.s:677    .text.sem_GiveUpOnSem:00000000 $t
        R_RTOS_sem.s:682    .text.sem_GiveUpOnSem:00000000 sem_GiveUpOnSem
        R_RTOS_sem.s:707    .text.sem_DeleteTskSemQ:00000000 $t
        R_RTOS_sem.s:712    .text.sem_DeleteTskSemQ:00000000 sem_DeleteTskSemQ
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.features.h.22.6a4ca7cd053637cc1d0db6c16f39b2d7
                           .group:00000000 wm4._default_types.h.15.8b2cb27e528498f8ff711db085d6e489
                           .group:00000000 wm4.stdint.h.20.796e373797e732130a803d4c0338fa1b
                           .group:00000000 wm4.R_RTOS_inc.h.33.90af6908e359466da96cfb5569754ce2
                           .group:00000000 wm4.R_RTOS_sem.h.19.ef9bebdb7f49b1a8b107db7ec548beb0
                           .group:00000000 wm4.R_RTOS_memMngr.h.14.e71363defcaed3db880eddd5ae4849f6

UNDEFINED SYMBOLS
memMngr_CreateMemPool
tsk_AR
tsk_ClrEvt
memMngr_MemPoolFree
memMngr_MemPoolMalloc
tsk_SetEvt
tsk_ChngePrio
sem_InsertTskSemQ
